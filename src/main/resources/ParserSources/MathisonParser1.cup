 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package SyntacticalAnalizer;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import LexicalAnalizer.Lexer;
import java.util.Scanner;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.LinkedList;
import SemanticAnalizer.*;

action code {:
    //public HashMap<String, Object> tablaSimbolos = new HashMap<String, Object>();

    //Se declaran las variables de control del árbol semántico.
    public Componente raiz = new Programa();

    public String imprimirArbol() {
            //Recorrido en profundidad primero
            if (raiz == null) return "";
            return toStringAux("", 0,  raiz);
    }

    private String toStringAux(String text,int indexLevel, Componente actual){
        if (actual == null) return text;

        text += '\n';
        for (int i = 0; i < indexLevel; i++) text += "|\t";

        text += actual.toString();

        if (actual.getTblSimbolosLocales() != null  && !actual.getTblSimbolosLocales().isEmpty()) {
                  text += '\n';
                  for (int i = 0; i < indexLevel; i++) text += "|\t";
                  text += "TABLA SIMBOLOS: " + actual.getTblSimbolosLocales().toString();
                }

        if ( actual.getHijoMasIzq() != null){
            text = toStringAux(text, indexLevel + 1, actual.getHijoMasIzq());
        }
        if ( actual.getHermanoDerecho() != null ){
            text = toStringAux(text, indexLevel, actual.getHermanoDerecho());
        }
        return text;
    }

    public boolean existeSimbolo(String nombre, Componente compActual, HashMap<String,Nombre> tabla){
        boolean existe = false;
        if(!tabla.containsKey(nombre))
        {
            Componente iterPadres = compActual.getPadre();
            while (iterPadres != null && !existe)
            {
                if (iterPadres.getTblSimbolosLocales() == null || !iterPadres.getTblSimbolosLocales().containsKey(nombre) || !(iterPadres.getTblSimbolosLocales().get(nombre) instanceof Variable))
                {
                    iterPadres = iterPadres.getPadre();
                }
                else{
                    existe = true;
                }
            }
            if(iterPadres == null)
            {
                existe = false;
            }
        }
        else {
            existe = true;
        }
        return existe;
    }

    public void llenarTabla() throws SemanticError
        {
            HashMap<String, Nombre> tablaSimbolos = new HashMap<String, Nombre>();
            LinkedList cola = new LinkedList();
            cola.addLast(raiz);
            int aparicion = 0;
            while (!cola.isEmpty()) //Mientras la cola no esté vacía
            {
                Componente aux = (Componente) cola.removeFirst();

                //Ver si es un simbolo guardado
                /*if(aux instanceof  Clase || aux instanceof Metodo)
                {
                    Nombre simbolo = (Nombre) aux;
                    System.out.println("Soy " + simbolo.get_nombre());
                }
                else
                {
                    System.out.println("Soy solo un " + aux.toString());
                }*/

                Componente hijo = aux.getHijoMasIzq();
                while (hijo != null) //Mientras tenga hijos
                {
                    hijo.setPadre(aux);
                    cola.addLast(hijo);
                    hijo.setOrdenAparicion(aparicion);

                    /*if (hijo instanceof Para){
                        Para para = (Para) hijo;
                        if (!existeSimbolo(para.get_variable(),hijo,tablaSimbolos))
                            tablaSimbolos.put(declaracion.get_nombre(), new Variable(declaracion.get_nombre(), declaracion.get_tipo(), declaracion.is_arreglo()));
                        else throw new SemanticError("ERROR SEMANTICO: Declaración duplicada de variable: " + declaracion.get_nombre());
                    }*/
                    //Agregar a la tabla del padre si es Clase, Metodo o Variable
                    if(hijo instanceof Clase)
                    {
                        Clase hijoSimbolo = (Clase) hijo;
                        hijoSimbolo.setOrdenAparicion(aparicion);
                        if (!existeSimbolo(hijoSimbolo.get_nombre(),(Componente) hijoSimbolo,tablaSimbolos))
                            tablaSimbolos.put(hijoSimbolo.get_nombre(), hijoSimbolo);
                        else throw new SemanticError("ERROR SEMANTICO: Declaracion duplicada de clase: " + hijoSimbolo.get_nombre());
                    }
                    if(hijo instanceof Metodo)
                    {
                        Metodo hijoSimbolo = (Metodo) hijo;
                        hijoSimbolo.setOrdenAparicion(aparicion);
                        if (!existeSimbolo(hijoSimbolo.get_nombre(),hijoSimbolo,tablaSimbolos))
                            tablaSimbolos.put(hijoSimbolo.get_nombre(), hijoSimbolo);
                        else throw new SemanticError("ERROR SEMANTICO: Declaración duplicada de metodo: " + hijoSimbolo.get_nombre());
                        //Agregamos los parametros como declaraciones
                        List<Variable> variables = hijoSimbolo.getParametros();
                        for ( Variable i:variables ) {
                            Declaracion decl = new Declaracion(i.get_nombre(),i.get_tipo(),i.is_arreglo());
                            decl.setHermanoDerecho(hijoSimbolo.getHijoMasIzq());
                            hijoSimbolo.setHijoMasIzq(decl);
                        }

                    }
                    if (hijo instanceof Declaracion){
                        Declaracion declaracion = (Declaracion) hijo;
                        if (!existeSimbolo(declaracion.get_nombre(),hijo,tablaSimbolos))
                        {
                            Variable variable = new Variable(declaracion.get_nombre(), declaracion.get_tipo(), declaracion.is_arreglo());
                            variable.setOrdenAparicion(aparicion);
                            tablaSimbolos.put(declaracion.get_nombre(), variable);
                        }
                        else throw new SemanticError("ERROR SEMANTICO: Declaración duplicada de variable: " + declaracion.get_nombre());
                    }
                    hijo = hijo.getHermanoDerecho();
                    aparicion++;
                }
                aux.setTblSimbolosLocales(tablaSimbolos);

                //System.out.println("Tabla asignada a " + aux.toString() + "\n" + aux.getTblSimbolosLocales().toString());

                tablaSimbolos = new HashMap<String, Nombre>(); //Reinicia la tabla del padre
            }
        }

        public boolean verificarExistencias() throws SemanticError
        {
            boolean todoBien = true;
            LinkedList cola = new LinkedList();
            cola.addLast(raiz.getHijoMasIzq());
            HashSet<String> metodosNativos = new HashSet<String>();
                metodosNativos.add("raiz");
            while (cola.size() != 0 && todoBien) //Mientras la cola no esté vacía
            {
                Componente aux = (Componente) cola.removeFirst();
                HashMap<String, Nombre> tabla = aux.getTblSimbolosLocales();
                Componente hijo = aux.getHijoMasIzq();
                while (hijo != null && todoBien) //Mientras tenga hijos
                {

                    if(hijo instanceof Variable)
                    {
                        String nombre = ((Variable) hijo).get_nombre();
                        if(!tabla.containsKey(nombre))
                        {
                            Componente iterPadres = aux;
                            while (iterPadres != null)
                            {
                                if (!iterPadres.getTblSimbolosLocales().containsKey(nombre) || !(iterPadres.getTblSimbolosLocales().get(nombre) instanceof Variable))
                                {
                                    iterPadres = iterPadres.getPadre();
                                }else break;
                            }
                            if(iterPadres == null)
                            {
                                todoBien = false;
                                throw new SemanticError("ERROR SEMANTICO: Referencia no declarada en " + hijo.getPadre().toString() + ": " + nombre);
                            }
                        }
                    }
                    if(hijo instanceof Asignacion)
                    {
                        String nombre = ((Asignacion) hijo).get_nombre();
                        if(!tabla.containsKey(nombre))
                        {
                            Componente iterPadres = aux;
                            while (iterPadres != null)
                            {
                                if (!iterPadres.getTblSimbolosLocales().containsKey(nombre) || !(iterPadres.getTblSimbolosLocales().get(nombre) instanceof Variable))
                                {
                                    iterPadres = iterPadres.getPadre();
                                }else break;
                            }
                            if(iterPadres == null)
                            {
                                todoBien = false;
                                throw new SemanticError("ERROR SEMANTICO: Referencia no declarada en " + hijo.getPadre().toString() + ": " + nombre);
                            }
                        }
                        else //Si lo tiene, debe buscar que se declaró antes de usarlo
                        {
                            Variable simbolo = (Variable) tabla.get(nombre);
                            if(hijo.getOrdenAparicion() < simbolo.getOrdenAparicion())
                                throw new SemanticError("ERROR SEMANTICO: Variable todavia no declarada: " + nombre);
                        }
                    }
                    if (hijo instanceof LlamadaMetodo){
                        String nombre = ((LlamadaMetodo) hijo).getNombre();
                        if (!metodosNativos.contains(nombre)){
                            if(!tabla.containsKey(nombre))
                            {
                                Componente iterPadres = aux;
                                while (iterPadres != null)
                                {
                                    if (!iterPadres.getTblSimbolosLocales().containsKey(nombre) || !(iterPadres.getTblSimbolosLocales().get(nombre) instanceof Metodo))
                                    {
                                        iterPadres = iterPadres.getPadre();
                                    }else break;
                                }
                                if(iterPadres == null)
                                {
                                    todoBien = false;
                                    throw new SemanticError("ERROR SEMANTICO: Referencia no declarada en " + hijo.getPadre().toString() + ": " + nombre);
                                }
                            }
                        }
                    }
                    cola.addLast(hijo);
                    hijo = hijo.getHermanoDerecho();
                }
            }
            return todoBien;
        }

:}

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
        //--------------------------------------------------------INICIO DE INTERVENCIÓN
            //Intervención para no tomar como entrada los parámetros del programa
            System.out.println("Escriba la dirección del archivo que desea analizar:");
            Scanner scan = new Scanner(System.in);
            args = scan.nextLine().split(" ");
            //--------------------------------------------------------FIN DE INTERVENCIÓN

            if (args.length == 0) {
              System.out.println("Usage : java Lexer [ --encoding <name> ] <inputfile(s)>");
            }
            else {
              int firstFilePos = 0;
              String encodingName = "UTF-8";
              if (args[0].equals("--encoding")) {
                firstFilePos = 2;
                encodingName = args[1];
                try {
                  java.nio.charset.Charset.forName(encodingName); // Side-effect: is encodingName valid?
                } catch (Exception e) {
                  System.out.println("Invalid encoding '" + encodingName + "'");
                  return;
                }
              }
              for (int i = firstFilePos; i < args.length; i++) {
                Lexer lexer = null;
                try {

                  //String path = Lexer.class.getResource(args[i]).getPath();
                  //java.io.FileInputStream stream = new java.io.FileInputStream(path);

                  //Se utiliza getResource para como root la carpeta Resources como Root
                    java.io.Reader reader = new java.io.InputStreamReader(Parser.class.getResourceAsStream("../" + args[i]), encodingName);
                    lexer = new Lexer(reader);
                                        //--------------------------------------------------------Aplicacion de PARSER
                                      Parser asin = new Parser(lexer);
                                        Object result = asin.parse().value;
                }
                catch (java.io.FileNotFoundException e) {
                  System.out.println("File not found : \""+args[i]+"\"" + e.getMessage());
                }
                catch (java.io.IOException e) {
                  System.out.println("IO error scanning file \""+args[i]+"\"");
                  System.out.println(e);
                }
                catch (Exception e) {
                  System.out.println("Unexpected exception:");
                  e.printStackTrace();
                }
              }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */

//PALABRAS RESERVADAS
terminal    Y, O, PARA, DESDE, HASTA, AVANCE, MIENTRAS, HACER, SI, SINO;
terminal    DEVOLVER, PROC, CLASE, CAD, BOOL, PUBLICO, PRIVADO;
terminal    IMPRIMIR, LEER, VERDADERO, FALSO, NUM, NEGACION;
terminal    REVISAR, CASO, DEFECTO;

terminal    MENORQUE, MAYORQUE, MENOROIGUAL, MAYOROIGUAL, DISTINTO, IGUAL;

//ASGNACION
terminal    ASIGNACION;


//ARITMETICA
terminal    SUMA, RESTA, MULTIPLICACION, DIVISION, NEGATIVO;

//DELIMITADOR
terminal    CORCHETEABIERTO,CORCHETECERRADO,LLAVEABIERTO,LLAVECERRADO,PARENTESISABIERTO,PARENTESISCERRADO, DOSPUNTOS, COMA;

terminal SALIR;

//CON VALOR ASOCIADO
terminal    Double NUMERO;
terminal    String VAR;
//terminal    String DELIMITADOR;
terminal    String CADENA;

/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
//non terminal Object     expr_list, expr_part;
//non terminal Integer    expr, factor, termino;

non terminal Componente programa;//--------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Clase clase;//----------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Componente cuerpo_clase;//---------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Metodo c_metodo;//-------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal List<Variable> lista_parametros;
non terminal Variable variable_arreglo;//-------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal    c_vista,  c_tipo_metodo, c_declaracion_metodo;
non terminal Declaracion c_declaracion;//-------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal c_tipo, c_tipo_primitivo, c_tipo_arreglo;


non terminal c_expresion_variable;
non terminal c_expresion_variable_mayorque, c_expresion_variable_mayoroigual, c_expresion_variable_menorque,c_expresion_variable_menoroigual;
non terminal c_expresion_variable_igual, c_expresion_variable_distinto;
non terminal c_expresion_variable_comparacion;

non terminal c_expresion_numerica;  //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Numerica_Total; //El total

non terminal c_expresion_booleana; //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Booleana_Total;

non terminal c_expresion_cadena; //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Cadena_total; //El total

non terminal Componente c_asignacion;//---------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Object c_asignacion_prima;
non terminal c_asignacion_booleana;

/*Llamado a Metodos*/
non terminal c_variable_o_llamadoMetodo;
non terminal LlamadaMetodo c_llamadoMetodo;//---------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal LlamadaMetodo c_expresion_llamado_metodo;
non terminal List<Object> c_lleno_parametros;
non terminal c_hay_parametro; //Estan en trabajo

/*Estructuras de control*/
non terminal Estructura c_estructuras;
non terminal Para c_para;//-------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Mientras c_mientras;//-----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Si c_si;//-----------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Sino c_sino;//-------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Revisar c_revisar;//-------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal c_revisar_casos;

/* Lineas validas */
non terminal Componente c_lista_sentencias;//------------------------------------------------------------------------------------------------------OBJETO ASIGNADO

non terminal Sentencia c_funciones_reservadas;
non terminal Imprimir c_imprimir;//----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Leer c_leer;//------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Devolver c_devolver;//-----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO

non terminal Componente cuerpo_metodo;

/*Inicio de las precedence, se guian en base a la documentacion de java
Entre más abajo esten tienen más prioridad*/



precedence left MENORQUE,MENOROIGUAL,MAYORQUE,MAYOROIGUAL;

precedence left DISTINTO,IGUAL;

precedence left Y,O;

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left NEGATIVO, NEGACION;

precedence left COMA;

precedence left PARENTESISABIERTO,PARENTESISCERRADO;


start with programa;

programa ::= clase:c programa:p
           {: c.setHermanoDerecho(p); RESULT = c; raiz = RESULT;:}
           | clase:c
           {: RESULT = c; raiz = RESULT;:}
           | c_metodo:m programa:p
           {: m.setHermanoDerecho(p); RESULT = m;  raiz = RESULT;:}
           | c_metodo:m
           {: RESULT = m; raiz = RESULT;:}
           ;
/* ------------------------------ Sintaxis de la estructura de un programa ------------------------------*/

clase ::= c_vista CLASE VAR:v LLAVEABIERTO cuerpo_clase LLAVECERRADO {: RESULT = new Clase(v); :}

        //--------------------------------------------------------Gramáticas erróneas
        //ERROR: LLave inicial faltante
        | c_vista CLASE VAR:v cuerpo_clase LLAVECERRADO {: System.out.println("CLASE " + v); report_error("Llave de apertura faltante (\" { \") en declaración de clase:\t" + v, null);:}
        ;

c_metodo ::= c_vista c_tipo_arreglo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_arreglo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_primitivo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_primitivo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); //System.out.println("METODO " + v);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, ls); //System.out.println("METODO " + v);:}
           | c_vista PROC VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, null, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, null, ls); //System.out.println("METODO " + v);:}
           | c_tipo_arreglo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | c_tipo_arreglo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); System.out.println("METODO " + v);:}
           | c_tipo_primitivo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | VAR:w VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, lp, ls); //System.out.println("METODO " + v);:}
           | c_tipo_primitivo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); //System.out.println("METODO " + v);:}
           | VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, ls); //System.out.println("METODO " + v);:}
           | PROC VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, null, lp, ls); //System.out.println("METODO " + v);:}
           | PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, null, ls); //System.out.println("METODO " + v);:}

           //--------------------------------------------------------Gramáticas erróneas
           // ERROR: Llave inicial faltante
           | c_vista c_tipo_arreglo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_arreglo VAR:v PARENTESISABIERTO PARENTESISCERRADO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_primitivo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_primitivo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_arreglo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_arreglo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_primitivo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | VAR:w VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_primitivo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           ;

c_vista ::= PUBLICO
          | PRIVADO
          ;

lista_parametros ::= c_tipo_primitivo variable_arreglo:v COMA lista_parametros:lp
                    {: lp.add(v); RESULT = lp; :}
                   | VAR:w variable_arreglo:v COMA lista_parametros:lp
                    {: lp.add(v); RESULT = lp; :}
                   | c_tipo_primitivo variable_arreglo:v
                    {: List<Variable> lp = new LinkedList<Variable>(); lp.add(v); RESULT = lp; :}
                   | VAR:w variable_arreglo:v
                    {: List<Variable> lp = new LinkedList<Variable>(); lp.add(v); RESULT = lp; :}

                    //--------------------------------------------------------Gramáticas erróneas
                    //ERROR: FALTAN COMAS
                   | c_tipo_primitivo variable_arreglo lista_parametros         {: report_error("Coma faltante (\" , \") en separación de parametros", null);:}
                   | VAR:w variable_arreglo lista_parametros                    {: report_error("Coma faltante (\" , \") en separación de parametros", null);:}
                   ;

variable_arreglo ::= VAR:v
                    {: RESULT = new Variable(v); :}
                   | VAR:v CORCHETEABIERTO CORCHETECERRADO
                   {: RESULT = new Variable(v,null,true); :}
                   | VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO
                   {: RESULT = new Variable(v,null,true); :}

                   //--------------------------------------------------------Gramáticas erróneas
                   //ERROR: FALTA DE CORCHETES
                   //| VAR:v CORCHETECERRADO                                          {: report_fatal_error("Corchete abierto faltante (\" [ \") en referencia a arreglo " + v, null);:}
                   ;

cuerpo_clase ::= c_metodo:m cuerpo_clase:c
                {: m.setHermanoDerecho(c); RESULT = m; :}
               | c_asignacion:a cuerpo_clase:c
               {: a.setHermanoDerecho(c); RESULT = a;:}
               | c_declaracion:d cuerpo_clase:c
               {: d.setHermanoDerecho(c); RESULT = d; :}
               |
               ;

cuerpo_metodo ::= c_lista_sentencias:l
                {:RESULT = l;:}
                ;

/*------------------------------ Sintaxis de los metodos ------------------------------*/

c_expresion_llamado_metodo ::= VAR:v PARENTESISABIERTO c_lleno_parametros:p PARENTESISCERRADO
                                {: RESULT = new LlamadaMetodo(p,v); :}
                            //--------------------------------------------------------Gramáticas erróneas
                            //ERROR FATAL: FALTAN COMAS
                            //|  VAR:v c_lleno_parametros PARENTESISABIERTO {: report_error("FATAL: Falta apertura de paréntesis (\" ( \") en llamada a método:\t" + v, null);:}
                            //|  VAR:v PARENTESISABIERTO c_lleno_parametros   {: report_error("FATAL: Falta apertura de paréntesis (\" ( \") en llamada a método:\t" + v, null);:}
                             ;

c_lleno_parametros ::= c_hay_parametro {:RESULT = new LinkedList<Object>();:}//TODO Revisar la lista de parametrso en llamadas a metodos
                     | PARENTESISABIERTO c_lleno_parametros:p PARENTESISCERRADO {:RESULT = p;:}
                     |  {:RESULT = new LinkedList<Object>(); :}
                     ;

c_hay_parametro ::= c_hay_parametro COMA c_hay_parametro
                  | c_variable_o_llamadoMetodo
                  //| c_expresion_variable_concatena
                  /*Demás expresiones sin variable*/
                  | c_expresion_numerica
                  | c_expresion_cadena
                  | c_expresion_booleana
                  | PARENTESISABIERTO c_hay_parametro PARENTESISCERRADO
                  //--------------------------------------------------------Gramáticas erróneas
                  //ERROR FATAL: FALTAN COMAS
                   c_hay_parametro c_hay_parametro       {: report_fatal_error("Coma faltante (\" , \") en separación de parametros", null);:}
                  ;

//c_definicion::= NUM c_asignacion_numerica
//|CAD c_asignacion_cadena
//|BOOL c_asignacion_booleana
  //;

/*-----------------------------Sintaxis de estructuras de control-------------------------- */

c_estructuras ::= c_para:p
                  {: RESULT = p;:}
                | c_mientras:m
                {: RESULT = m;:}
                | c_si:s
                {: RESULT = s;:}
                | c_revisar:r
                {: RESULT = r;:}
                | c_sino:sn
                {: RESULT = sn;:}
                ;

c_para ::=  PARA VAR:v DESDE c_asignacion_expresion_Numerica_Total HASTA c_asignacion_expresion_Numerica_Total
            AVANCE c_asignacion_expresion_Numerica_Total LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
            {: Asignacion a = new Asignacion(v); a.setHermanoDerecho(ls);RESULT = new Para(v, a);:}//TODO Agregar listas de expresiones para el desde, el hasta y avance (estos no se pueden simplemente agregar al scope)
         |  PARA NUM VAR:v DESDE c_asignacion_expresion_Numerica_Total HASTA c_asignacion_expresion_Numerica_Total
            AVANCE c_asignacion_expresion_Numerica_Total LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
            {: Asignacion a = new Asignacion(v); Declaracion decl = new Declaracion(v, Tipo.NUMERICO); decl.setHermanoDerecho(a); a.setHermanoDerecho(ls); RESULT = new Para(v, decl);:}
         ;

c_mientras ::= MIENTRAS PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO
               HACER LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
               {: RESULT = new Mientras(ls);:}//TODO Revisar las expresiones de los MIENTRAS
             | HACER LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO MIENTRAS
               PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO
               {: RESULT = new Mientras(ls);:}
             ;

c_si ::= //SI PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO c_sino
         //{: RESULT = new Si(ls);:}
           SI PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
          {: RESULT = new Si(ls);:}//TODO Revisar las expresiones de los SI
       ;

c_sino ::= SINO c_si
           {: RESULT = new Sino();:}
         | SINO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
           {: RESULT = new Sino(ls);:}
         ;
//POR DECISIÓN SE QUITÓ
c_revisar ::= REVISAR PARENTESISABIERTO VAR:v PARENTESISCERRADO LLAVEABIERTO c_revisar_casos LLAVECERRADO //TODO: Revisar los casos de las REVISIONES
              {: RESULT = new Revisar();:}
            ;

c_revisar_casos ::= CASO c_expresion_numerica DOSPUNTOS c_lista_sentencias SALIR
                  | DEFECTO DOSPUNTOS c_lista_sentencias SALIR
                  ;

c_lista_sentencias ::= c_asignacion:a c_lista_sentencias:ls
                      {: a.getUltimoHermano().setHermanoDerecho(ls); RESULT = a; :}//Se coloca así porque a puede ser una lista de elemetos entoces hay que buscar el ultimo elemento para ligarlo.
                     | c_declaracion:d c_lista_sentencias:ls
                     {: d.setHermanoDerecho(ls); RESULT = d; :}
                     | c_estructuras:e c_lista_sentencias:ls
                     {: e.setHermanoDerecho(ls); RESULT = e; :}
                     | c_expresion_llamado_metodo:m c_lista_sentencias:ls
                     {: m.setHermanoDerecho(ls); RESULT = m; :}
                     | c_funciones_reservadas:f c_lista_sentencias:ls
                     {: f.setHermanoDerecho(ls); RESULT = f; :}
                     |
                     ;

/*------------------------------Declaracion Basica ------------------------------*/

c_declaracion ::= c_tipo_primitivo:t VAR:v                                                          {: RESULT = new Declaracion(v,(Tipo) t); //System.out.println("Declaración " + v);:}
                | VAR:w VAR:v                                                                       {: RESULT = new Declaracion(v,Tipo.NO_PRIMITIVO, w); //System.out.println("Declaración " + v);:}
                //TODOold Agregar el nombre de la clase
                | c_tipo_primitivo:t VAR:v CORCHETEABIERTO CORCHETECERRADO                          {: RESULT = new Declaracion(v,(Tipo) t,true); //System.out.println("Declaración de arreglo" + v);:}
                | VAR:w VAR:v CORCHETEABIERTO CORCHETECERRADO                                       {: RESULT = new Declaracion(v, Tipo.NO_PRIMITIVO, true, w); //System.out.println("Declaración de arreglo" + v);:}
                | c_tipo_primitivo:t VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO  {: RESULT = new Declaracion(v,(Tipo) t, true); //System.out.println("Declaración de arreglo" + v);:}
                | VAR:w VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO {: RESULT = new Declaracion(v,Tipo.NO_PRIMITIVO, true, w); //System.out.println("Declaración de arreglo" + v);:}
                | c_tipo_arreglo:t VAR:v                                                              {: RESULT = new Declaracion(v,(Tipo)t, true); //System.out.println("Declaración de arreglo" + v);:}
                //TODOold Checkear los no primitivos de los arreglos
                ;

/*------------------------------Primitivas de tipo de datos------------------------------*/

c_tipo ::= c_tipo_primitivo:t                                               {: RESULT = t; :}
         | VAR:tipo_no_primitivo                                            {: RESULT = Tipo.NO_PRIMITIVO;:}//Una clase
         ;

c_tipo_primitivo ::= CAD                                                    {: RESULT = Tipo.CADENA;:}
                  | NUM                                                     {: RESULT = Tipo.NUMERICO;:}
                  | BOOL                                                    {: RESULT = Tipo.BOOLEANO;:}
                  ;

c_tipo_arreglo ::=  c_tipo_primitivo:t CORCHETEABIERTO CORCHETECERRADO      {: RESULT = t;:}
                |   VAR:w CORCHETEABIERTO CORCHETECERRADO                   {: RESULT = Tipo.NO_PRIMITIVO;:}                    //Pasar por alguna parte el nombre del tipo
                |   c_tipo_primitivo:t CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO {: RESULT = t;:}
                |   VAR:w CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO {: RESULT = Tipo.NO_PRIMITIVO;:}//Pasar por alguna parte el nombre del tipo
                ;

/*-------------------------Sintaxis de las variables y operaciones con variables------------------------*/
//TODO Para añadir soporte a orientación a objetos agregar esta linea
//c_variable_o_llamadoMetodo ::= c_expresion_variable:v PUNTO c_variable_o_llamadoMetodo
c_variable_o_llamadoMetodo ::= c_expresion_variable:v     {: RESULT = v;//System.out.println("Variable de expresion");:}
                             | c_llamadoMetodo:v          {: RESULT = v;//System.out.println("Llamado a metodo en expresion");:}
                             ;

c_llamadoMetodo ::= c_expresion_llamado_metodo:m                            {: RESULT = m;:}
                  | PARENTESISABIERTO c_llamadoMetodo:m PARENTESISCERRADO   {: RESULT = m;:}
                  ;

c_expresion_variable ::= variable_arreglo:v                                         {:RESULT = v;:}
                       | PARENTESISABIERTO c_expresion_variable:v PARENTESISCERRADO {:RESULT = v;:}
                       ;
//TODO Agregar solo reducciones y linkeo de variables o llamados a métodos al arbol
c_expresion_variable_igual ::= c_expresion_numerica:e IGUAL c_expresion_numerica:f                      {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                             | c_expresion_booleana:e  IGUAL c_expresion_booleana:f                     {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                             | c_expresion_booleana:e  IGUAL c_variable_o_llamadoMetodo:m               {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex;:}
                             | c_variable_o_llamadoMetodo:m  IGUAL c_asignacion_booleana:e              {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}

                             | c_variable_o_llamadoMetodo:m IGUAL c_expresion_numerica:e                {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}
                             | c_expresion_numerica:e IGUAL c_variable_o_llamadoMetodo:m                {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex;:}
                             | c_variable_o_llamadoMetodo:m IGUAL c_variable_o_llamadoMetodo:n          {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = ex;:}
                             ;

c_expresion_variable_distinto ::=c_expresion_numerica:e DISTINTO c_expresion_numerica:f                 {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                              |  c_expresion_booleana:e  DISTINTO c_expresion_booleana:f                {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                              | c_expresion_booleana:e  DISTINTO c_variable_o_llamadoMetodo:m           {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex;:}
                              | c_variable_o_llamadoMetodo:m  DISTINTO c_asignacion_booleana:e          {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}
                              |  c_variable_o_llamadoMetodo:m DISTINTO c_expresion_numerica:e           {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}
                               | c_expresion_numerica:e DISTINTO c_variable_o_llamadoMetodo:m           {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex;:}
                               | c_variable_o_llamadoMetodo:m DISTINTO c_variable_o_llamadoMetodo:n     {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = ex;:}
                               ;

c_expresion_variable_mayorque ::= c_asignacion_expresion_Numerica_Total:e MAYORQUE c_asignacion_expresion_Numerica_Total:f  {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                                ;


c_expresion_variable_mayoroigual ::= c_asignacion_expresion_Numerica_Total:e MAYOROIGUAL c_asignacion_expresion_Numerica_Total:f {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                                   ;

c_expresion_variable_menorque ::= c_asignacion_expresion_Numerica_Total:e MENORQUE c_asignacion_expresion_Numerica_Total:f {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                                ;

c_expresion_variable_menoroigual ::= c_asignacion_expresion_Numerica_Total:e MENOROIGUAL c_asignacion_expresion_Numerica_Total:f {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;:}
                                   ;

c_expresion_variable_comparacion ::= c_expresion_variable_igual:e           {:RESULT = e;:}
                                   | c_expresion_variable_distinto:e        {:RESULT = e;:}
                                   | c_expresion_variable_mayorque:e        {:RESULT = e;:}
                                   | c_expresion_variable_mayoroigual:e     {:RESULT = e;:}
                                   | c_expresion_variable_menorque:e        {:RESULT = e;:}
                                   | c_expresion_variable_menoroigual:e     {:RESULT = e;:}
                                   ;

/*------------------------------Declaracion de las asignaciones------------------------------*/

c_asignacion ::=    c_tipo_primitivo:t VAR:v c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); asignacion.setHijoMasIzq((Componente)o); RESULT.setHermanoDerecho(asignacion);:}
                |   c_tipo_primitivo:t VAR:v CORCHETEABIERTO CORCHETECERRADO c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); asignacion.setHijoMasIzq((Componente)o); RESULT.setHermanoDerecho(asignacion);:}
                |   c_tipo_primitivo:t VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); asignacion.setHijoMasIzq((Componente)o); RESULT.setHermanoDerecho(asignacion);:}
                |   c_tipo_arreglo:t VAR:v c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); asignacion.setHijoMasIzq((Componente)o); RESULT.setHermanoDerecho(asignacion);:}
                |   VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total CORCHETECERRADO c_asignacion_prima:o
                    {:RESULT = new Asignacion(v); RESULT.setHijoMasIzq((Componente)o);:}
                |   VAR:v c_asignacion_prima:o
                    {:RESULT = new Asignacion(v); RESULT.setHijoMasIzq((Componente)o);:}
               ;

/*------------------------------Sintaxis asignacion de tipo numericas------------------------------*/

c_asignacion_prima ::=  ASIGNACION c_expresion_numerica:e       {:RESULT = e;:}    //Asignacion numerica
                    |   ASIGNACION c_expresion_cadena           {:RESULT = new ExpresionGenerico("Expresion");:}
                    |   ASIGNACION c_expresion_booleana         {:RESULT = new ExpresionGenerico("Expresion");:}
                    |   ASIGNACION c_variable_o_llamadoMetodo:e {:RESULT = e;:}
                    ;
c_asignacion_expresion_Numerica_Total ::= c_expresion_numerica:e        {:RESULT = e;:} //Corresponde a todas aquellas menos las que tienen solo variables
                                        | c_variable_o_llamadoMetodo:e  {:RESULT = e;:}
                                        ;


c_expresion_numerica  ::= c_expresion_numerica:e SUMA c_expresion_numerica:f            {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;//System.out.println("c_expresion_numerica SUMA c_expresion_numerica");:}
                        | c_expresion_numerica:e RESTA c_expresion_numerica:f           {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; //System.out.println("c_expresion_numerica RESTA c_expresion_numerica");:}
                        | c_expresion_numerica:e MULTIPLICACION c_expresion_numerica:f  {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;//System.out.println("c_expresion_numerica MULTIPLICACION c_expresion_numerica");:}
                        | c_expresion_numerica:e DIVISION c_expresion_numerica:f        {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;//System.out.println("c_expresion_numerica DIVISION c_expresion_numerica");:}
                        | RESTA c_expresion_numerica:e %prec NEGATIVO
                        | RESTA c_variable_o_llamadoMetodo:v %prec NEGATIVO

                        //Una variable + otra cosa

                        | c_variable_o_llamadoMetodo:m SUMA c_expresion_numerica:f      {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                        | c_expresion_numerica:f SUMA c_variable_o_llamadoMetodo:m          {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                        | c_variable_o_llamadoMetodo:m RESTA c_expresion_numerica:f         {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                        | c_expresion_numerica:f RESTA c_variable_o_llamadoMetodo:m         {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                        | c_variable_o_llamadoMetodo:m MULTIPLICACION c_expresion_numerica:f{: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                        | c_expresion_numerica:f MULTIPLICACION c_variable_o_llamadoMetodo:m{: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                        | c_variable_o_llamadoMetodo:m DIVISION c_expresion_numerica:f      {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                        | c_expresion_numerica:f DIVISION c_variable_o_llamadoMetodo:m      {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                        //Dos variables

                        | c_variable_o_llamadoMetodo:m SUMA c_variable_o_llamadoMetodo:n    {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = m; :}//Esta operación contempla la concatenación de cadenas y la suma de literales numéricos.
                        | c_variable_o_llamadoMetodo:m RESTA c_variable_o_llamadoMetodo:n   {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = m; :}
                        | c_variable_o_llamadoMetodo:m MULTIPLICACION c_variable_o_llamadoMetodo:n{: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = m; :}
                        | c_variable_o_llamadoMetodo:m DIVISION c_variable_o_llamadoMetodo:n{: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = m; :}

                        //Terminos
                        | NUMERO:v                                                      {: RESULT = new ExpresionGenerico(v.toString());:}  //{:System.out.println("Numero " + v);:}
                        | PARENTESISABIERTO c_expresion_numerica:e PARENTESISCERRADO    {: RESULT = e;:}
                        ;

c_asignacion_expresion_Cadena_total ::= c_expresion_cadena:e {: RESULT = e;:}  //Cuando al menos una no es una variable
                                      ;

/*------------------------------Sintaxis de tipo cadena tipo numericas------------------------------*/

c_expresion_cadena ::= c_expresion_cadena:e SUMA c_expresion_cadena:f               {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex;//System.out.println("c_expresion_numerica SUMA c_expresion_numerica");:}
                     //Una variable + otra cosa
                     | c_variable_o_llamadoMetodo:m SUMA c_expresion_cadena:f       {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                     | c_expresion_cadena:f SUMA c_variable_o_llamadoMetodo:m       {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}
                     | CADENA:v                                                     {:RESULT = new ExpresionGenerico(v);//System.out.println("Cadena " + v);:}
                     //|c_nombre_metodo
                     | PARENTESISABIERTO c_expresion_cadena:e PARENTESISCERRADO     {: RESULT = e;:}
                     ;

/*------------------------------ Sintaxis de tipo cadena tipo booleana------------------------------*/

c_asignacion_expresion_Booleana_Total ::= c_expresion_booleana:e            {:RESULT = e;:}//Corresponde a todas las operaciones excpeto cuando todas son variables
                                        | c_variable_o_llamadoMetodo:e      {:RESULT = e;:}
                                        ;

/*c_asignacion_booleana ::= BOOL VAR:V ASIGNACION c_asignacion_expresion_Booleana_Total
                        ;
*/

c_expresion_booleana::= c_expresion_booleana:e  Y c_expresion_booleana:f                {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                      | c_expresion_booleana:e O c_expresion_booleana:f                 {: Componente ex = (Componente)e; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                      | DISTINTO c_expresion_booleana %prec NEGACION
                      | DISTINTO c_variable_o_llamadoMetodo %prec NEGACION


                      //Una variables o más + otra cosa

                      | c_variable_o_llamadoMetodo:m Y c_expresion_booleana:f           {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                      | c_expresion_booleana:f Y c_variable_o_llamadoMetodo:m           {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                      | c_variable_o_llamadoMetodo:m O c_expresion_booleana:f           {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)f); RESULT = ex; :}
                      | c_expresion_booleana:f O c_variable_o_llamadoMetodo:m           {: Componente ex = (Componente)f; ex.getUltimoHermano().setHermanoDerecho((Componente)m); RESULT = ex; :}

                      //Dos variables o más + otra cosa

                      | c_variable_o_llamadoMetodo:m Y c_variable_o_llamadoMetodo:n         {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = ex; :}
                      | c_variable_o_llamadoMetodo:m O c_variable_o_llamadoMetodo:n         {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)n); RESULT = ex; :}

                      | c_expresion_variable_comparacion
                      | VERDADERO                                                   {:RESULT = new ExpresionGenerico("VERDADERO");:}
                      | FALSO                                                       {:RESULT = new ExpresionGenerico("FALSO");:}
                      | PARENTESISABIERTO c_expresion_booleana:e PARENTESISCERRADO  {:RESULT = e;:}
                      ;


/*------------------------------ Sintaxis de otras funciones reservadas ------------------------------*/

c_imprimir ::= IMPRIMIR PARENTESISABIERTO c_expresion_cadena:e PARENTESISCERRADO
                {: RESULT = new Imprimir(); RESULT.setHijoMasIzq((Componente)e);:}
             | IMPRIMIR PARENTESISABIERTO c_variable_o_llamadoMetodo:e PARENTESISCERRADO
                {: RESULT = new Imprimir(); RESULT.setHijoMasIzq((Componente)e);:}
             | IMPRIMIR PARENTESISABIERTO NUMERO:n PARENTESISCERRADO
                {: RESULT = new Imprimir(n);:}
             ;

c_leer ::= LEER PARENTESISABIERTO VAR:v PARENTESISCERRADO
            {: RESULT = new Leer(v); :}
         ;

c_devolver ::= DEVOLVER c_variable_o_llamadoMetodo:o
                {: RESULT = new Devolver(o); :}
             | DEVOLVER c_expresion_numerica:e
                {: RESULT = new Devolver(e); :}
             | DEVOLVER c_expresion_cadena:e
                {: RESULT = new Devolver(e); :}
             | DEVOLVER c_expresion_booleana:e
                {: RESULT = new Devolver(e); :}
             ;

c_funciones_reservadas ::= c_imprimir:i   {: RESULT = i;:}
                         | c_leer:l       {: RESULT = l;:}
                         | c_devolver:d   {: RESULT = d;:}
                         ;

