 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package SyntacticalAnalizer;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import LexicalAnalizer.Lexer;
import java.util.Scanner;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.LinkedList;
import SemanticAnalizer.*;
import java.lang.System.exit;

action code {:

:}

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
        //--------------------------------------------------------INICIO DE INTERVENCIÓN
            //Intervención para no tomar como entrada los parámetros del programa
            System.out.println(
                                "  __  __           _     _       _\n" +
                                " |  \\/  |   __ _  | |_  | |__   (_)  ___    ___    _ __\n" +
                                " | |\\/| |  / _` | | __| | '_ \\  | | / __|  / _ \\  | '_ \\\n" +
                                " | |  | | | (_| | | |_  | | | | | | \\__ \\ | (_) | | | | |\n" +
                                " |_|  |_|  \\__,_|  \\__| |_| |_| |_| |___/  \\___/  |_| |_|\n" +
                                "                               PROGRAMACIÓN PARA HISPANOS"
                        );

            System.out.println("\n" +
                                "  *********************ACCESO*RAPIDO********************\n" +
                                "  * [1] Compilar 'Criba de Eratostenes'                *\n" +
                                "  * [2] Compilar 'Sucesion de Fibonacci'               *\n" +
                                "  * [3] Compilar 'Triangulo'                           *\n" +
                                "  ******************************************************\n"

            );
            String[] direcciones = {"Codes/eratostenes.mathison",
                                    "Codes/fibonacci.mathison",
                                    "Codes/triangulo.mathison"
                                   };
            while (true){
                System.out.println("\nDigite una opcion o escriba la direccion del archivo a compilar...");
                Scanner scan = new Scanner(System.in);
                args = scan.nextLine().split(" ");
                //--------------------------------------------------------FIN DE INTERVENCIÓN

                if (args.length == 0) {
                    System.out.println("Usage : java Lexer [ --encoding <name> ] <inputfile(s)>");
                }
                else {
                    int firstFilePos = 0;
                    String encodingName = "UTF-8";
                    if (args[0].equals("--encoding")) {
                        firstFilePos = 2;
                        encodingName = args[1];
                        try {
                            java.nio.charset.Charset.forName(encodingName); // Side-effect: is encodingName valid?
                        } catch (Exception e) {
                            System.out.println("Invalid encoding '" + encodingName + "'");
                            return;
                        }
                    }
                    for (int i = firstFilePos; i < args.length; i++) {
                        Lexer lexer = null;
                        try {

                            //String path = Lexer.class.getResource(args[i]).getPath();
                            //java.io.FileInputStream stream = new java.io.FileInputStream(path);

                            if (args[i].equals("1")) args[i] = direcciones[0];
                            else if (args[i].equals("2")) args[i] = direcciones[1];
                            else if (args[i].equals("3")) args[i] = direcciones[2];
                            else if (args[i].equals("salir")) exit(1);


                            //Se utiliza getResource para como root la carpeta Resources como Root
                            java.io.Reader reader = new java.io.InputStreamReader(Parser.class.getResourceAsStream("../" + args[i]), encodingName);
                            lexer = new Lexer(reader);
                            //--------------------------------------------------------Aplicacion de PARSER
                            Parser asin = new Parser(lexer);
                            System.out.println("-------------------INICIO-DE-COMPILACIÓN--------------------------");
                            Object result = asin.parse().value;
                            System.out.println("----------------------FIN-DE-COMPILACIÓN--------------------------");
                        }
                        catch (java.io.FileNotFoundException e) {
                            System.out.println("File not found : \""+args[i]+"\"");
                        }
                        catch (java.io.IOException e) {
                            System.out.println("IO error scanning file \""+args[i]+"\"");
                            System.out.println(e);
                        }
                        catch (Exception e) {
                            System.out.println("Unexpected exception:");
                            e.printStackTrace();
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }


:};
   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */

//PALABRAS RESERVADAS
terminal    Y, O, PARA, DESDE, HASTA, AVANCE, MIENTRAS, HACER, SI, SINO;
terminal    DEVOLVER, PROC, CLASE, CAD, BOOL, PUBLICO, PRIVADO;
terminal    IMPRIMIR, LEER, VERDADERO, FALSO, NUM, NEGACION;
terminal    REVISAR, CASO, DEFECTO;

terminal    MENORQUE, MAYORQUE, MENOROIGUAL, MAYOROIGUAL, DISTINTO, IGUAL;

//ASGNACION
terminal    ASIGNACION;


//ARITMETICA
terminal    SUMA, RESTA, MULTIPLICACION, DIVISION, NEGATIVO;

//DELIMITADOR
terminal    CORCHETEABIERTO,CORCHETECERRADO,LLAVEABIERTO,LLAVECERRADO,PARENTESISABIERTO,PARENTESISCERRADO, DOSPUNTOS, COMA;

terminal SALIR;

//CON VALOR ASOCIADO
terminal    Double NUMERO;
terminal    String VAR;
//terminal    String DELIMITADOR;
terminal    String CADENA;

/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
//non terminal Object     expr_list, expr_part;
//non terminal Integer    expr, factor, termino;

non terminal Componente programa;//--------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Clase clase;//----------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Componente cuerpo_clase;//---------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Metodo c_metodo;//-------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal List<Variable> lista_parametros;
non terminal Variable variable_arreglo;//-------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal c_vista,  c_tipo_metodo, c_declaracion_metodo;
non terminal Declaracion c_declaracion;//-------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal c_tipo, c_tipo_primitivo;
non terminal ArregloPOJO c_tipo_arreglo;//-------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO

non terminal Variable c_expresion_variable;

non terminal Expresion c_expresion_variable_mayorque;
non terminal Expresion c_expresion_variable_mayoroigual;
non terminal Expresion c_expresion_variable_menorque;
non terminal Expresion c_expresion_variable_menoroigual;
non terminal Expresion c_expresion_variable_igual;
non terminal Expresion c_expresion_variable_distinto;

non terminal Expresion c_expresion_variable_comparacion;

non terminal Expresion c_expresion_numerica;  //Todas las operaciones excepto solamente el nombre e la variable
non terminal Expresion c_asignacion_expresion_Numerica_Total; //El total

non terminal Expresion c_expresion_booleana; //Todas las operaciones excepto solamente el nombre e la variable
non terminal Expresion c_asignacion_expresion_Booleana_Total;

non terminal Expresion c_expresion_cadena; //Todas las operaciones excepto solamente el nombre e la variable
non terminal Expresion c_asignacion_expresion_Cadena_total; //El total

non terminal Componente c_asignacion;//---------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Expresion c_asignacion_prima;
non terminal c_asignacion_booleana;

/*Llamado a Metodos*/
non terminal Nombre c_variable_o_llamadoMetodo;
non terminal LlamadaMetodo c_llamadoMetodo;//---------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal LlamadaMetodo c_expresion_llamado_metodo;
non terminal List<Expresion> c_lleno_parametros;
non terminal List<Expresion> c_hay_parametro; //Estan en trabajo

/*Estructuras de control*/
non terminal Estructura c_estructuras;
non terminal Para c_para;//-------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Mientras c_mientras;//-----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Si c_si;//-----------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Si c_sino;//-------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Revisar c_revisar;//-------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal c_revisar_casos;

/* Lineas validas */
non terminal Componente c_lista_sentencias;//------------------------------------------------------------------------------------------------------OBJETO ASIGNADO

non terminal Sentencia c_funciones_reservadas;
non terminal Imprimir c_imprimir;//----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Leer c_leer;//------------------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO
non terminal Devolver c_devolver;//-----------------------------------------------------------------------------------------------------------------------OBJETO ASIGNADO

non terminal Componente cuerpo_metodo;

/*Inicio de las precedence, se guian en base a la documentacion de java
Entre más abajo esten tienen más prioridad*/

precedence left MENORQUE,MENOROIGUAL,MAYORQUE,MAYOROIGUAL;

precedence left DISTINTO,IGUAL;

precedence left Y,O;

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left NEGATIVO, NEGACION;

precedence left COMA;

precedence left PARENTESISABIERTO,PARENTESISCERRADO;


start with programa;

programa ::= clase:c programa:p
           {: c.setHermanoDerecho(p); RESULT = c; Programa.getInstance().setRaiz(RESULT);:}
           | clase:c
           {: RESULT = c; Programa.getInstance().setRaiz(RESULT);:}
           | c_metodo:m programa:p
           {: m.setHermanoDerecho(p); RESULT = m;  Programa.getInstance().setRaiz(RESULT);:}
           | c_metodo:m
           {: RESULT = m; Programa.getInstance().setRaiz(RESULT);:}
           ;
/* ------------------------------ Sintaxis de la estructura de un programa ------------------------------*/

clase ::= c_vista CLASE VAR:v LLAVEABIERTO cuerpo_clase LLAVECERRADO {: RESULT = new Clase(v); :}

        //--------------------------------------------------------Gramáticas erróneas
        //ERROR: LLave inicial faltante
        | c_vista CLASE VAR:v cuerpo_clase LLAVECERRADO {: System.out.println("CLASE " + v); report_error("Llave de apertura faltante (\" { \") en declaración de clase:\t" + v, null);:}
        ;

c_metodo ::= c_vista c_tipo_arreglo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, t, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_arreglo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, t, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_primitivo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista c_tipo_primitivo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); //System.out.println("METODO " + v);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, ls); //System.out.println("METODO " + v);:}
           | c_vista PROC VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, lp, ls); //System.out.println("METODO " + v);:}
           | c_vista PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, ls); //System.out.println("METODO " + v);:}
           | c_tipo_arreglo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, t, lp, ls); //System.out.println("METODO " + v);:}
           | c_tipo_arreglo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, t, ls); System.out.println("METODO " + v);:}
           | c_tipo_primitivo:t VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, lp, ls); //System.out.println("METODO " + v);:}
           | VAR:w VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, lp, ls); //System.out.println("METODO " + v);:}
           | c_tipo_primitivo:t VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, (Tipo) t, ls); //System.out.println("METODO " + v);:}
           | VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, Tipo.NO_PRIMITIVO, ls); //System.out.println("METODO " + v);:}
           | PROC VAR:v PARENTESISABIERTO lista_parametros:lp PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, lp, ls); //System.out.println("METODO " + v);:}
           | PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo:ls LLAVECERRADO
           {: RESULT = new Metodo(v, ls); //System.out.println("METODO " + v);:}

           //--------------------------------------------------------Gramáticas erróneas
           // ERROR: Llave inicial faltante
           | c_vista c_tipo_arreglo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_arreglo VAR:v PARENTESISABIERTO PARENTESISCERRADO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_primitivo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista c_tipo_primitivo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_vista PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_arreglo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_arreglo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_primitivo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | VAR:w VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | c_tipo_primitivo VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | VAR:w VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           | PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO  cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v); report_error("Llave de apertura faltante (\" { \") en declaración de método:\t" + v, null);:}
           ;

c_vista ::= PUBLICO
          | PRIVADO
          ;

lista_parametros ::= c_tipo_primitivo:t variable_arreglo:v COMA lista_parametros:lp
                    {: v.setTipo((Tipo)t); ((LinkedList<Variable>)lp).addFirst(v); RESULT = lp; :}
                   | VAR:w variable_arreglo:v COMA lista_parametros:lp
                    {: v.setTipo(Tipo.NO_PRIMITIVO); ((LinkedList<Variable>)lp).addFirst(v); RESULT = lp; :}
                   | c_tipo_primitivo:t variable_arreglo:v
                    {: List<Variable> lp = new LinkedList<Variable>(); v.setTipo((Tipo)t); lp.add(v); RESULT = lp; :}
                   | VAR:w variable_arreglo:v
                    {: List<Variable> lp = new LinkedList<Variable>(); v.setTipo(Tipo.NO_PRIMITIVO); lp.add(v); RESULT = lp; :}

                    //--------------------------------------------------------Gramáticas erróneas
                    //ERROR: FALTAN COMAS
                   | c_tipo_primitivo variable_arreglo lista_parametros         {: report_error("Coma faltante (\" , \") en separación de parametros", null);:}
                   | VAR:w variable_arreglo lista_parametros                    {: report_error("Coma faltante (\" , \") en separación de parametros", null);:}
                   ;

variable_arreglo ::= VAR:v
                    {: RESULT = new Variable(v); :}
                   | VAR:v CORCHETEABIERTO CORCHETECERRADO
                   {: RESULT = new Variable(v,true); :} //TODO Esta produccion es innecesaria
                   | VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO
                   {: RESULT = new Variable(v,e,true); :}

                   //--------------------------------------------------------Gramáticas erróneas
                   //ERROR: FALTA DE CORCHETES
                   //| VAR:v CORCHETECERRADO                                          {: report_fatal_error("Corchete abierto faltante (\" [ \") en referencia a arreglo " + v, null);:}
                   ;

cuerpo_clase ::= c_metodo:m cuerpo_clase:c
                {: m.setHermanoDerecho(c); RESULT = m; :}
               | c_asignacion:a cuerpo_clase:c
               {: a.setHermanoDerecho(c); RESULT = a;:}
               | c_declaracion:d cuerpo_clase:c
               {: d.setHermanoDerecho(c); RESULT = d; :}
               |
               ;

cuerpo_metodo ::= c_lista_sentencias:l
                {:RESULT = l;:}
                ;

/*------------------------------ Sintaxis de los metodos ------------------------------*/

c_expresion_llamado_metodo ::= VAR:v PARENTESISABIERTO c_lleno_parametros:p PARENTESISCERRADO
                                {: RESULT = new LlamadaMetodo(p,v); :}
                            //--------------------------------------------------------Gramáticas erróneas
                            //ERROR FATAL: FALTAN COMAS
                            //|  VAR:v c_lleno_parametros PARENTESISABIERTO {: report_error("FATAL: Falta apertura de paréntesis (\" ( \") en llamada a método:\t" + v, null);:}
                            //|  VAR:v PARENTESISABIERTO c_lleno_parametros   {: report_error("FATAL: Falta apertura de paréntesis (\" ( \") en llamada a método:\t" + v, null);:}
                             ;

c_lleno_parametros ::= c_hay_parametro:p {:RESULT = p;:}
                     | PARENTESISABIERTO c_lleno_parametros:p PARENTESISCERRADO {:RESULT = p;:}//TODO Esta linea no tiene sentido
                     |  {:RESULT = null; :}
                     ;

c_hay_parametro ::= c_hay_parametro:p COMA c_hay_parametro:f        {: p.addAll(f); RESULT = p;:}
                  | c_variable_o_llamadoMetodo:m                      {:List<Expresion> p = new LinkedList<Expresion>(); p.add((Expresion)m); RESULT = p;:}
                  //| c_expresion_variable_concatena
                  /*Demás expresiones sin variable*/
                  | c_expresion_numerica:e                            {: List<Expresion> p = new LinkedList<Expresion>(); p.add(e); RESULT = p;:}
                  | c_expresion_cadena:e                              {: List<Expresion> p = new LinkedList<Expresion>(); p.add(e); RESULT = p;:}
                  | c_expresion_booleana:e                            {: List<Expresion> p = new LinkedList<Expresion>(); p.add(e); RESULT = p;:}
                  | PARENTESISABIERTO c_hay_parametro:p PARENTESISCERRADO {:RESULT = p;:}
                  //--------------------------------------------------------Gramáticas erróneas
                  //ERROR FATAL: FALTAN COMAS
                   c_hay_parametro c_hay_parametro       {: report_fatal_error("Coma faltante (\" , \") en separación de parametros", null);:}
                  ;

/*-----------------------------Sintaxis de estructuras de control-------------------------- */

c_estructuras ::= c_para:p
                  {: RESULT = p;:}
                | c_mientras:m
                {: RESULT = m;:}
                | c_si:s
                {: RESULT = s;:}
                //| c_revisar:r
                //{: RESULT = r;:}
                | c_sino:sn
                {: RESULT = sn;:}
                ;

c_para ::=  PARA VAR:v DESDE c_asignacion_expresion_Numerica_Total:desde HASTA c_asignacion_expresion_Numerica_Total:hasta
            AVANCE c_asignacion_expresion_Numerica_Total:avance LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
            {: Asignacion a = new Asignacion(v); a.set_expresion(desde); a.setHermanoDerecho(ls);RESULT = new Para(v, a, desde, hasta, avance);:}
         |  PARA NUM VAR:v DESDE c_asignacion_expresion_Numerica_Total:desde HASTA c_asignacion_expresion_Numerica_Total:hasta
            AVANCE c_asignacion_expresion_Numerica_Total:avance LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
            {: Asignacion a = new Asignacion(v); a.set_expresion(desde); Declaracion decl = new Declaracion(v, Tipo.NUMERICO); a.setHermanoDerecho(ls); RESULT = new Para(v, decl, a, desde, hasta, avance);:}
         ;

c_mientras ::= MIENTRAS PARENTESISABIERTO c_asignacion_expresion_Booleana_Total:e PARENTESISCERRADO
               HACER LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
               {: RESULT = new Mientras(ls); RESULT.set_condicion((Expresion) e);:}//TODO Revisar las expresiones de los MIENTRAS
             | HACER LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO MIENTRAS
               PARENTESISABIERTO c_asignacion_expresion_Booleana_Total:e PARENTESISCERRADO
               {: RESULT = new Mientras(ls); RESULT.set_condicion((Expresion) e);:}
             ;

c_si ::= //SI PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO c_sino
         //{: RESULT = new Si(ls);:}
           SI PARENTESISABIERTO c_asignacion_expresion_Booleana_Total:exp PARENTESISCERRADO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
          {: RESULT = new Si(exp, ls);:}//TODO Revisar las expresiones de los SI
       ;

c_sino ::= //SINO c_si
           //{: RESULT = new Sino();:}
          c_si:si SINO LLAVEABIERTO c_lista_sentencias:ls LLAVECERRADO
           {: Sino sino = new Sino(ls); si.setHermanoDerecho(sino);RESULT = si;:}
         ;
//POR DECISIÓN SE QUITÓ
c_revisar ::= REVISAR PARENTESISABIERTO VAR:v PARENTESISCERRADO LLAVEABIERTO c_revisar_casos LLAVECERRADO //TODO: Revisar los casos de las REVISIONES
              {: RESULT = new Revisar(); report_fatal_error("La verga",((Parser) this.parser).stack.peek());:}
            ;

c_revisar_casos ::= CASO c_expresion_numerica DOSPUNTOS c_lista_sentencias SALIR
                  | DEFECTO DOSPUNTOS c_lista_sentencias SALIR
                  ;

c_lista_sentencias ::= c_asignacion:a c_lista_sentencias:ls
                      {: a.getUltimoHermano().setHermanoDerecho(ls); RESULT = a; :}//Se coloca así porque a puede ser una lista de elemetos entoces hay que buscar el ultimo elemento para ligarlo.
                     | c_declaracion:d c_lista_sentencias:ls
                     {: d.setHermanoDerecho(ls); RESULT = d; :}
                     | c_estructuras:e c_lista_sentencias:ls
                     {: e.getUltimoHermano().setHermanoDerecho(ls); RESULT = e; :}
                     | c_expresion_llamado_metodo:m c_lista_sentencias:ls
                     {: m.setHermanoDerecho(ls); RESULT = m; :}
                     | c_funciones_reservadas:f c_lista_sentencias:ls
                     {: f.setHermanoDerecho(ls); RESULT = f; :}
                     |
                     ;

/*------------------------------Declaracion Basica ------------------------------*/

c_declaracion ::= c_tipo_primitivo:t VAR:v                                                          {: RESULT = new Declaracion(v,(Tipo) t); //System.out.println("Declaración " + v);:}
                | VAR:w VAR:v                                                                       {: RESULT = new Declaracion(v,Tipo.NO_PRIMITIVO, w); //System.out.println("Declaración " + v);:}
                //TODOold Agregar el nombre de la clase
                | c_tipo_primitivo:t VAR:v CORCHETEABIERTO CORCHETECERRADO                          {: RESULT = new Declaracion(v,(Tipo) t,true); //System.out.println("Declaración de arreglo" + v);:}
                | VAR:w VAR:v CORCHETEABIERTO CORCHETECERRADO                                       {: RESULT = new Declaracion(v, Tipo.NO_PRIMITIVO, true, w); //System.out.println("Declaración de arreglo" + v);:}
                | c_tipo_primitivo:t VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO  {: RESULT = new Declaracion(v,(Tipo) t, e); //System.out.println("Declaración de arreglo" + v);:}
                | VAR:w VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO {: RESULT = new Declaracion(v,Tipo.NO_PRIMITIVO, e, w); //System.out.println("Declaración de arreglo" + v);:}
                | c_tipo_arreglo:t VAR:v                                                              {: RESULT = new Declaracion(v,t, true); //System.out.println("Declaración de arreglo" + v);:}
                //TODOold Checkear los no primitivos de los arreglos
                ;

/*------------------------------Primitivas de tipo de datos------------------------------*/

c_tipo ::= c_tipo_primitivo:t                                               {: RESULT = t; :}
         | VAR:tipo_no_primitivo                                            {: RESULT = Tipo.NO_PRIMITIVO;:}//Una clase
         ;

c_tipo_primitivo ::= CAD                                                    {: RESULT = Tipo.CADENA;:}
                  | NUM                                                     {: RESULT = Tipo.NUMERICO;:}
                  | BOOL                                                    {: RESULT = Tipo.BOOLEANO;:}
                  ;

c_tipo_arreglo ::=  c_tipo_primitivo:t CORCHETEABIERTO CORCHETECERRADO      {: RESULT = new ArregloPOJO((Tipo)t);:}
                |   VAR:w CORCHETEABIERTO CORCHETECERRADO                   {: RESULT = new ArregloPOJO(Tipo.NO_PRIMITIVO, w);:}                    //Pasar por alguna parte el nombre del tipo
                |   c_tipo_primitivo:t CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO {: RESULT = new ArregloPOJO((Tipo)t, e);:}
                |   VAR:w CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO {: RESULT = new ArregloPOJO(Tipo.NO_PRIMITIVO, w, e);:}//Pasar por alguna parte el nombre del tipo
                ;

/*-------------------------Sintaxis de las variables y operaciones con variables------------------------*/
//TODO Para añadir soporte a orientación a objetos agregar esta linea
//c_variable_o_llamadoMetodo ::= c_expresion_variable:v PUNTO c_variable_o_llamadoMetodo
c_variable_o_llamadoMetodo ::= c_expresion_variable:v     {: RESULT = v;//System.out.println("Variable de expresion");:}
                             | c_llamadoMetodo:m          {: RESULT = m;//System.out.println("Llamado a metodo en expresion");:}
                             ;

c_llamadoMetodo ::= c_expresion_llamado_metodo:m                            {: RESULT = m;:}
                  | PARENTESISABIERTO c_llamadoMetodo:m PARENTESISCERRADO   {: RESULT = m;:}
                  ;

c_expresion_variable ::= variable_arreglo:v                                         {:RESULT = v;:}
                       | PARENTESISABIERTO c_expresion_variable:v PARENTESISCERRADO {:RESULT = v;:}
                       ;

c_expresion_variable_igual ::= c_expresion_numerica:e IGUAL c_expresion_numerica:f                      {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, e, f);:}
                             | c_expresion_booleana:e  IGUAL c_expresion_booleana:f                     {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, e, f);:}
                             | c_expresion_booleana:e  IGUAL c_variable_o_llamadoMetodo:m               {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, e, (Expresion) m);:}
                             //| c_variable_o_llamadoMetodo:m  IGUAL c_asignacion_booleana:e              {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}

                             | c_variable_o_llamadoMetodo:m IGUAL c_expresion_numerica:e                {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, (Expresion) m, e);:}
                             | c_expresion_numerica:e IGUAL c_variable_o_llamadoMetodo:m                {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, e, (Expresion) m);:}
                             | c_variable_o_llamadoMetodo:m IGUAL c_variable_o_llamadoMetodo:n          {: RESULT = new Operacion(Operacion.TipoOperador.IGUAL, (Expresion) m, (Expresion) n);:}
                             ;

c_expresion_variable_distinto ::=c_expresion_numerica:e DISTINTO c_expresion_numerica:f                 {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, e, f);:}
                              |  c_expresion_booleana:e  DISTINTO c_expresion_booleana:f                {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, e, f);:}
                              | c_expresion_booleana:e  DISTINTO c_variable_o_llamadoMetodo:m           {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, e, (Expresion) m);:}
                              //| c_variable_o_llamadoMetodo:m  DISTINTO c_asignacion_booleana:e          {: Componente ex = (Componente)m; ex.getUltimoHermano().setHermanoDerecho((Componente)e); RESULT = ex;:}
                              |  c_variable_o_llamadoMetodo:m DISTINTO c_expresion_numerica:e           {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, (Expresion) m, e);:}
                               | c_expresion_numerica:e DISTINTO c_variable_o_llamadoMetodo:m           {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, e, (Expresion) m);:}
                               | c_variable_o_llamadoMetodo:m DISTINTO c_variable_o_llamadoMetodo:n     {: RESULT = new Operacion(Operacion.TipoOperador.DISTINTO, (Expresion) m, (Expresion) n);:}
                               ;

c_expresion_variable_mayorque ::= c_asignacion_expresion_Numerica_Total:e MAYORQUE c_asignacion_expresion_Numerica_Total:f  {: RESULT = new Operacion(Operacion.TipoOperador.MAYORQUE, e, f);:}
                                ;


c_expresion_variable_mayoroigual ::= c_asignacion_expresion_Numerica_Total:e MAYOROIGUAL c_asignacion_expresion_Numerica_Total:f {: RESULT = new Operacion(Operacion.TipoOperador.MAYOROIGUAL, e, f);:}
                                   ;

c_expresion_variable_menorque ::= c_asignacion_expresion_Numerica_Total:e MENORQUE c_asignacion_expresion_Numerica_Total:f {: RESULT = new Operacion(Operacion.TipoOperador.MENORQUE, e, f);:}
                                ;

c_expresion_variable_menoroigual ::= c_asignacion_expresion_Numerica_Total:e MENOROIGUAL c_asignacion_expresion_Numerica_Total:f {: RESULT = new Operacion(Operacion.TipoOperador.MENOROIGUAL, e, f);:}
                                   ;

c_expresion_variable_comparacion ::= c_expresion_variable_igual:e           {:RESULT = e;:}
                                   | c_expresion_variable_distinto:e        {:RESULT = e;:}
                                   | c_expresion_variable_mayorque:e        {:RESULT = e;:}
                                   | c_expresion_variable_mayoroigual:e     {:RESULT = e;:}
                                   | c_expresion_variable_menorque:e        {:RESULT = e;:}
                                   | c_expresion_variable_menoroigual:e     {:RESULT = e;:}
                                   ;

/*------------------------------Declaracion de las asignaciones------------------------------*/

c_asignacion ::=    c_tipo_primitivo:t VAR:v c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); RESULT.setHermanoDerecho(asignacion); asignacion.set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
                |   c_tipo_primitivo:t VAR:v CORCHETEABIERTO CORCHETECERRADO c_asignacion_prima:o
                    {:RESULT = new Declaracion(v, (Tipo)t); Asignacion asignacion = new Asignacion(v); RESULT.setHermanoDerecho(asignacion); asignacion.set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
                |   //Ejemplo: num nombreTrivial[5] = 3 + 5 <- no tiene sentido         TODO Definir si esto tendría validez
                    c_tipo_primitivo:t VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO c_asignacion_prima:o//TODO Checkear la expresion del indice
                    {:RESULT = new Declaracion(v, (Tipo)t,e); Asignacion asignacion = new Asignacion(v,e); RESULT.setHermanoDerecho(asignacion); asignacion.set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
                |   //Ejemplo: num[6] nombreTrivial = 6 + 9 <- no tiene sentido         TODO Definir si esto tendría validez
                    c_tipo_arreglo:t VAR:v c_asignacion_prima:o                         //TODO Faltan producciones para la definicion de arreglos
                    {:RESULT = new Declaracion(v, t, true); Asignacion asignacion = new Asignacion(v,t.get_expresionTamano()); RESULT.setHermanoDerecho(asignacion); asignacion.set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
                |   VAR:v CORCHETEABIERTO c_asignacion_expresion_Numerica_Total:e CORCHETECERRADO c_asignacion_prima:o
                    {:RESULT = new Asignacion(v,e); ((Asignacion)RESULT).set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
                |   VAR:v c_asignacion_prima:o
                    {:RESULT = new Asignacion(v); ((Asignacion)RESULT).set_expresion(o); //System.out.println(RESULT.get_expresion().toString());:}
               ;

/*------------------------------Sintaxis asignacion de tipo numericas------------------------------*/

c_asignacion_prima ::=  ASIGNACION c_expresion_numerica:e         {:RESULT = e;:}    //Asignacion numerica
                    |   ASIGNACION c_expresion_cadena:e           {:RESULT = e;:}
                    |   ASIGNACION c_expresion_booleana:e         {:RESULT = e;:}
                    |   ASIGNACION c_variable_o_llamadoMetodo:m   {:RESULT = (Expresion)m;:}
                    ;
c_asignacion_expresion_Numerica_Total ::= c_expresion_numerica:e        {:RESULT = e;:} //Corresponde a todas aquellas menos las que tienen solo variables
                                        | c_variable_o_llamadoMetodo:m  {:RESULT = (Expresion)m;:}
                                        ;


c_expresion_numerica  ::= c_expresion_numerica:e SUMA c_expresion_numerica:f            {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, e, f, Tipo.NUMERICO);:}
                        | c_expresion_numerica:e RESTA c_expresion_numerica:f           {: RESULT = new Operacion(Operacion.TipoOperador.RESTA, e, f, Tipo.NUMERICO);:}
                        | c_expresion_numerica:e MULTIPLICACION c_expresion_numerica:f  {: RESULT = new Operacion(Operacion.TipoOperador.MULTIPLICACION, e, f, Tipo.NUMERICO);:}
                        | c_expresion_numerica:e DIVISION c_expresion_numerica:f        {: RESULT = new Operacion(Operacion.TipoOperador.DIVISION, e, f, Tipo.NUMERICO);:}
                        | RESTA c_expresion_numerica:e                                  {:RESULT = e;:} %prec NEGATIVO
                        | RESTA c_variable_o_llamadoMetodo:m                            {:RESULT = (LlamadaMetodo)m;:} %prec NEGATIVO

                        //Una variable + otra cosa

                        | c_variable_o_llamadoMetodo:m SUMA c_expresion_numerica:f          {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, (Expresion) m, f);:}
                        | c_expresion_numerica:f SUMA c_variable_o_llamadoMetodo:m          {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, f, (Expresion) m);:}

                        | c_variable_o_llamadoMetodo:m RESTA c_expresion_numerica:f         {: RESULT = new Operacion(Operacion.TipoOperador.RESTA, (Expresion) m, f);:}
                        | c_expresion_numerica:f RESTA c_variable_o_llamadoMetodo:m         {: RESULT = new Operacion(Operacion.TipoOperador.RESTA, f, (Expresion) m);:}

                        | c_variable_o_llamadoMetodo:m MULTIPLICACION c_expresion_numerica:f{: RESULT = new Operacion(Operacion.TipoOperador.MULTIPLICACION, (Expresion) m, f);:}
                        | c_expresion_numerica:f MULTIPLICACION c_variable_o_llamadoMetodo:m{: RESULT = new Operacion(Operacion.TipoOperador.MULTIPLICACION, f, (Expresion) m);:}

                        | c_variable_o_llamadoMetodo:m DIVISION c_expresion_numerica:f      {: RESULT = new Operacion(Operacion.TipoOperador.DIVISION, (Expresion) m, f);:}
                        | c_expresion_numerica:f DIVISION c_variable_o_llamadoMetodo:m      {: RESULT = new Operacion(Operacion.TipoOperador.DIVISION, f, (Expresion) m);:}

                        //Dos variables

                        | c_variable_o_llamadoMetodo:m SUMA c_variable_o_llamadoMetodo:n    {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, (Expresion) m, (Expresion) n);:}
                        | c_variable_o_llamadoMetodo:m RESTA c_variable_o_llamadoMetodo:n   {: RESULT = new Operacion(Operacion.TipoOperador.RESTA, (Expresion) m, (Expresion) n);:}
                        | c_variable_o_llamadoMetodo:m MULTIPLICACION c_variable_o_llamadoMetodo:n  {: RESULT = new Operacion(Operacion.TipoOperador.MULTIPLICACION, (Expresion) m, (Expresion) n);:}
                        | c_variable_o_llamadoMetodo:m DIVISION c_variable_o_llamadoMetodo:n    {: RESULT = new Operacion(Operacion.TipoOperador.DIVISION, (Expresion) m, (Expresion) n);:}

                        //Terminos
                        | NUMERO:v                                                      {:RESULT = new ExpresionGenerico(sym.terminalNames[((Symbol)((Parser) this.parser).stack.peek()).sym],Tipo.NUMERICO,(Symbol)((Parser) this.parser).stack.peek());:}
                        | PARENTESISABIERTO c_expresion_numerica:e PARENTESISCERRADO    {: RESULT = e;:}
                        ;

/*------------------------------Sintaxis de tipo cadena ------------------------------*/
c_expresion_cadena ::= c_expresion_cadena:e SUMA c_expresion_cadena:f               {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, e, f, Tipo.CADENA);:} //SIEMPRE HAY CASTING IMPLICITOS
                     //Una variable + otra cosa
                     | c_variable_o_llamadoMetodo:m SUMA c_expresion_cadena:f       {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, (Expresion) m, f, Tipo.CADENA);:}
                     | c_expresion_cadena:f SUMA c_variable_o_llamadoMetodo:m       {: RESULT = new Operacion(Operacion.TipoOperador.SUMA, f, (Expresion) m, Tipo.CADENA);:}
                     | CADENA:v                                                     {:RESULT = new ExpresionGenerico(sym.terminalNames[((Symbol)((Parser) this.parser).stack.peek()).sym],Tipo.CADENA,(Symbol)((Parser) this.parser).stack.peek());:}
                     //|c_nombre_metodo
                     | PARENTESISABIERTO c_expresion_cadena:e PARENTESISCERRADO     {: RESULT = e;:}
                     ;

/*------------------------------ Sintaxis de tipo booleana------------------------------*/

c_asignacion_expresion_Booleana_Total ::= c_expresion_booleana:e            {:RESULT = e;:}//Corresponde a todas las operaciones excpeto cuando todas son variables
                                        | c_variable_o_llamadoMetodo:m      {:RESULT = (Expresion)m;:}
                                        ;


c_expresion_booleana::= c_expresion_booleana:e  Y c_expresion_booleana:f                {: RESULT = new Operacion(Operacion.TipoOperador.Y, e, f);:}
                      | c_expresion_booleana:e O c_expresion_booleana:f                 {: RESULT = new Operacion(Operacion.TipoOperador.O, e, f);:}
                      | DISTINTO c_expresion_booleana:e                                 {: RESULT = e;:}%prec NEGACION //TODO token DISTINTO no es !
                      | DISTINTO c_variable_o_llamadoMetodo:m                           {: RESULT = (Expresion)m;:}%prec NEGACION


                      //Una variables o más + otra cosa

                      | c_variable_o_llamadoMetodo:m Y c_expresion_booleana:f           {: RESULT = new Operacion(Operacion.TipoOperador.Y, (Expresion) m, f);:}
                      | c_expresion_booleana:f Y c_variable_o_llamadoMetodo:m           {: RESULT = new Operacion(Operacion.TipoOperador.Y, f, (Expresion) m);:}

                      | c_variable_o_llamadoMetodo:m O c_expresion_booleana:f           {: RESULT = new Operacion(Operacion.TipoOperador.O, (Expresion) m, f);:}
                      | c_expresion_booleana:f O c_variable_o_llamadoMetodo:m           {: RESULT = new Operacion(Operacion.TipoOperador.O, f, (Expresion) m);:}

                      //Dos variables o más + otra cosa

                      | c_variable_o_llamadoMetodo:m Y c_variable_o_llamadoMetodo:n         {: RESULT = new Operacion(Operacion.TipoOperador.Y, (Expresion) m, (Expresion) n);:}
                      | c_variable_o_llamadoMetodo:m O c_variable_o_llamadoMetodo:n         {: RESULT = new Operacion(Operacion.TipoOperador.O, (Expresion) m, (Expresion) n);:}

                      | c_expresion_variable_comparacion:e                           {:RESULT = e;:}
                      | VERDADERO                                                   {:RESULT = new ExpresionGenerico(sym.terminalNames[((Symbol)((Parser) this.parser).stack.peek()).sym],Tipo.BOOLEANO,(Symbol)((Parser) this.parser).stack.peek());:}
                      | FALSO                                                       {:RESULT = new ExpresionGenerico(sym.terminalNames[((Symbol)((Parser) this.parser).stack.peek()).sym],Tipo.BOOLEANO,(Symbol)((Parser) this.parser).stack.peek());:}
                      | PARENTESISABIERTO c_expresion_booleana:e PARENTESISCERRADO  {:RESULT = e;:}
                      ;


/*------------------------------ Sintaxis de otras funciones reservadas ------------------------------*/

c_imprimir ::= IMPRIMIR PARENTESISABIERTO c_expresion_cadena:e PARENTESISCERRADO
                {: RESULT = new Imprimir(e);:}
             | IMPRIMIR PARENTESISABIERTO c_variable_o_llamadoMetodo:e PARENTESISCERRADO
                {: RESULT = new Imprimir((Expresion)e);:}
             | IMPRIMIR PARENTESISABIERTO NUMERO:n PARENTESISCERRADO
                {: RESULT = new Imprimir(new ExpresionGenerico(sym.terminalNames[((Symbol)((Parser) this.parser).stack.peek()).sym],Tipo.NUMERICO,(Symbol)((Parser) this.parser).stack.peek()));:}
             ;

c_leer ::= LEER PARENTESISABIERTO VAR:v PARENTESISCERRADO
            {: RESULT = new Leer(new Variable(v)); :}
         ;

c_devolver ::= DEVOLVER c_variable_o_llamadoMetodo:o
                {: RESULT = new Devolver((Expresion)o); :}
             | DEVOLVER c_expresion_numerica:e
                {: RESULT = new Devolver(e); :}
             | DEVOLVER c_expresion_cadena:e
                {: RESULT = new Devolver(e); :}
             | DEVOLVER c_expresion_booleana:e
                {: RESULT = new Devolver(e); :}
             ;

c_funciones_reservadas ::= c_imprimir:i   {: RESULT = i;:}
                         | c_leer:l       {: RESULT = l;:}
                         | c_devolver:d   {: RESULT = d;:}
                         ;

