 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package SyntacticalAnalizer;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import LexicalAnalizer.Lexer;
import java.util.Scanner;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
        //--------------------------------------------------------INICIO DE INTERVENCIÓN
            //Intervención para no tomar como entrada los parámetros del programa
            System.out.println("Escriba la dirección del archivo que desea analizar:");
            Scanner scan = new Scanner(System.in);
            args = scan.nextLine().split(" ");
            //--------------------------------------------------------FIN DE INTERVENCIÓN

            if (args.length == 0) {
              System.out.println("Usage : java Lexer [ --encoding <name> ] <inputfile(s)>");
            }
            else {
              int firstFilePos = 0;
              String encodingName = "UTF-8";
              if (args[0].equals("--encoding")) {
                firstFilePos = 2;
                encodingName = args[1];
                try {
                  java.nio.charset.Charset.forName(encodingName); // Side-effect: is encodingName valid?
                } catch (Exception e) {
                  System.out.println("Invalid encoding '" + encodingName + "'");
                  return;
                }
              }
              for (int i = firstFilePos; i < args.length; i++) {
                Lexer lexer = null;
                try {

                  //String path = Lexer.class.getResource(args[i]).getPath();
                  //java.io.FileInputStream stream = new java.io.FileInputStream(path);

                  //Se utiliza getResource para como root la carpeta Resources como Root
                    java.io.Reader reader = new java.io.InputStreamReader(Parser.class.getResourceAsStream("../" + args[i]), encodingName);
                    lexer = new Lexer(reader);
                                        //--------------------------------------------------------Aplicacion de PARSER
                                      Parser asin = new Parser(lexer);
                                        Object result = asin.parse().value;
                }
                catch (java.io.FileNotFoundException e) {
                  System.out.println("File not found : \""+args[i]+"\"" + e.getMessage());
                }
                catch (java.io.IOException e) {
                  System.out.println("IO error scanning file \""+args[i]+"\"");
                  System.out.println(e);
                }
                catch (Exception e) {
                  System.out.println("Unexpected exception:");
                  e.printStackTrace();
                }
              }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */

//PALABRAS RESERVADAS
terminal    Y, O, PARA, DESDE, HASTA, AVANCE, MIENTRAS, HACER, SI;
terminal    SINO, DEVOLVER, PROC, CLASE, REC, CAD, BOOL, PUBLICO;
terminal    PRIVADO, IMPRIMIR, LEER, FIN, VERDADERO, FALSO, IMPORTAR;
terminal    INTENTAR, ATRAPAR, LANZAR, CONSTANTE, REVISAR, CASO;
terminal    COMO, DEFECTO, CON, TERMINAR, EXCEPTO, MOSTRAR, EJECUTAR, NUM;
terminal    EN, CONTINUAR, FINALMENTE;

//COMPARACION
terminal    MEI, MAI, II, MENORQUE, MAYORQUE, MENOROIGUAL,MAYOROIGUAL,DISTINTO,IGUAL;

//ASGNACION
terminal ASIGNACION;


//ARITMETICA
terminal    SUMA, RESTA, MULTIPLICACION, DIVISION, MOD;

//DELIMITADOR
terminal    CORCHETEABIERTO,CORCHETECERRADO,LLAVEABIERTO,LLAVECERRADO,PARENTESISABIERTO,PARENTESISCERRADO, DOSPUNTOS, COMA;

terminal SALIR;

//CON VALOR ASOCIADO
terminal    Double NUMERO;
terminal    String VAR;
terminal    String DELIMITADOR;
terminal    String CADENA;

/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
//non terminal Object     expr_list, expr_part;
//non terminal Integer    expr, factor, termino;

non terminal    programa, lista_clases, clase, cuerpo_clase, sentencia, lista_sentencias;
non terminal    lista_metodos, metodo, lista_expresiones, expresion, lista_parametros, expresion_booleana, variable_arreglo;
non terminal    ciclo_para, ciclo_mientras, condicion, condicion_si, sino; //condicion_revisar, expresion_numerica, revisar0, asignacion;
non terminal    visibilidad,  tipo_metodo;
non terminal    c_declaracion,c_tipo;
non terminal c_asignacion;
non terminal c_asignacion_numerica,c_expresion_numerica;
non terminal c_asignacion_cadena, c_expresion_cadena;
non terminal c_asignacion_booleana, c_expresion_booleana,c_expresion_booleana_numerica;
non terminal c_definicion;


precedence nonassoc DISTINTO,IGUAL,MENORQUE,MENOROIGUAL,MAYORQUE,MAYOROIGUAL;

precedence left Y,O;

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MOD;


precedence left PARENTESISABIERTO,PARENTESISCERRADO;



start with programa;


/* -------------Seccion de predencia y asociacion de los terminales----------- */
   
/*
  Precedencia de los no terminales, no sirve con simbolos terminales.
  Por eso no la usamos. Además indica si se asocia a izquierda o derecha.
*/
  /*precedence left OP_SUMA, OP_RESTA;
  precedence left OP_MULT;*/


/* ------------------------- Seccion de la gramatica ------------------------- */



////--------------------------------------------------------Estructura general
//Un programa será un conjunto de clases y métodos
//. Sí, debido a que se enseñará a niños, se permite
//tener métodos sueltos. Además, tener un main (co
//ntrolador estático) dentro de un objeto nunca tu
//vo sentido.


               // c_tipo VAR:v

   programa ::= c_asignacion
                ;


  c_declaracion::= c_tipo VAR:v
  ;


  c_tipo ::= CAD
                           | NUM
                           | BOOL
                           | VAR:tipo_no_primitivo           //Una clase
                           ;

  c_asignacion::=c_asignacion_numerica c_asignacion
                |c_asignacion_cadena c_asignacion
                |c_asignacion_booleana c_asignacion
                |
  ;

c_asignacion_numerica::= NUM VAR:v ASIGNACION c_expresion_numerica
                        ;

 c_expresion_numerica  ::= c_expresion_numerica SUMA c_expresion_numerica
                           |c_expresion_numerica RESTA c_expresion_numerica
                           |c_expresion_numerica MULTIPLICACION c_expresion_numerica
                           |c_expresion_numerica DIVISION c_expresion_numerica
                           |NUMERO:v
                           |VAR:v
                           |PARENTESISABIERTO c_expresion_numerica PARENTESISCERRADO
                           ;


/*




 c_expresion_numerica2 ::= c_expresion_numerica2 MULTIPLICACION c_expresion_numerica3
                           |c_expresion_numerica2 DIVISION c_expresion_numerica3
                           |c_expresion_numerica3
                           ;

c_expresion_numerica3 ::=   NUMERO:v
                           |VAR:v
                           |PARENTESISABIERTO c_expresion_numerica PARENTESISCERRADO
                           ;

*/

c_asignacion_cadena::=CAD VAR:v ASIGNACION c_expresion_cadena
;


c_expresion_cadena  ::= c_expresion_cadena SUMA c_expresion_cadena
                           | CADENA:v
                           |VAR:v
                          |PARENTESISABIERTO c_expresion_cadena PARENTESISCERRADO
  ;

/*

c_expresion_cadena  ::= c_expresion_cadena SUMA c_expresion_cadena2
                           | c_expresion_cadena2
                           ;

c_expresion_cadena2  ::= CADENA:v
                     |VAR:v
                     |PARENTESISABIERTO c_expresion_cadena PARENTESISCERRADO

                     ;
*/

c_asignacion_booleana ::= BOOL VAR:V ASIGNACION c_expresion_booleana
                        ;


/*---FIJARSE SI BOOL DEVUELVE BIEN*/

c_expresion_booleana::=  c_expresion_booleana  Y c_expresion_booleana
                        |c_expresion_booleana O c_expresion_booleana
                        |BOOL:v

                        |VAR:v
                        |c_expresion_booleana_numerica //Si lo meto entre parentesis no funciona
                        |VERDADERO
                        |FALSO

                        |PARENTESISABIERTO VAR:v PARENTESISCERRADO
                        |PARENTESISABIERTO c_expresion_booleana  Y c_expresion_booleana PARENTESISCERRADO
                        |PARENTESISABIERTO c_expresion_booleana O c_expresion_booleana PARENTESISCERRADO
                        |PARENTESISABIERTO VERDADERO PARENTESISCERRADO
                        |PARENTESISABIERTO FALSO PARENTESISCERRADO
                        ;


c_expresion_booleana_numerica::= c_expresion_numerica MAYORQUE c_expresion_numerica
|c_expresion_numerica MAYOROIGUAL c_expresion_numerica
|c_expresion_numerica MENORQUE c_expresion_numerica
|c_expresion_numerica MENOROIGUAL c_expresion_numerica
|c_expresion_numerica DISTINTO c_expresion_numerica
|c_expresion_numerica IGUAL c_expresion_numerica
|PARENTESISABIERTO c_expresion_booleana_numerica PARENTESISCERRADO

 ;

//c_definicion::= NUM c_asignacion_numerica
//|CAD c_asignacion_cadena
//|BOOL c_asignacion_booleana
  //;




   /*   programa ::= clase programa
                | metodo programa
                | clase
                | metodo
                ;*/
/*
   lista_clases ::= clase lista_clases
                    | clase
                    ;
*/
   clase ::= visibilidad CLASE VAR:v LLAVEABIERTO cuerpo_clase LLAVECERRADO {: System.out.println("CLASE " + v);:}
           ;
/*
   lista_metodos ::= metodo lista_metodos
                 |  metodo
   	             ;
*/
   metodo ::= visibilidad tipo_metodo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO LLAVEABIERTO lista_sentencias LLAVECERRADO     {: System.out.println("METODO " + v);:}
            | visibilidad tipo_metodo VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO lista_sentencias LLAVECERRADO                      {: System.out.println("METODO " + v);:}
            ;

    visibilidad ::= PUBLICO
                       | PRIVADO
                       |
                       ;

   lista_parametros ::= c_tipo variable_arreglo COMA lista_parametros
                    |   c_tipo variable_arreglo
                    ;

   variable_arreglo ::= VAR:v
                    | VAR:v CORCHETEABIERTO CORCHETECERRADO
                    ;

   tipo_metodo ::= PROC
                | c_tipo
                ;

   cuerpo_clase ::= cuerpo_clase expresion
                    | cuerpo_clase metodo
                    |
                    ;

   /*cuerpo_clase ::= lista_expresiones
                    ;*/

   lista_sentencias ::=  ciclo_para lista_sentencias
                        | ciclo_mientras lista_sentencias
                        | condicion lista_sentencias
                        | expresion lista_sentencias
                        |
                        ;




    //TODO: Especificar más
 /*  lista_sentencias ::= lista_expresiones
                        ;
                        */



   /*sentencia ::= ciclo_para
                 | ciclo_mientras
                 | condicion_si
                 | condicion_revisar
                 | asignacion
                 |
                 ;*/
/*
   ciclo_para ::= PARA VAR:v DESDE expresion HASTA expresion_booleana AVANCE NUMERO:n LLAVEABIERTO lista_sentencias LLAVECERRADO;

   ciclo_mientras ::= MIENTRAS PARENTESISABIERTO expresion_booleana PARENTESISCERRADO HACER LLAVEABIERTO lista_sentencias LLAVECERRADO
                    | HACER LLAVEABIERTO lista_sentencias LLAVECERRADO MIENTRAS PARENTESISABIERTO expresion PARENTESISCERRADO DELIMITADOR
                    ;

   condicion_si ::= SI PARENTESISABIERTO expresion_booleana PARENTESISCERRADO LLAVEABIERTO lista_sentencias LLAVECERRADO sino
                  ;

   sino ::= SINO LLAVEABIERTO lista_sentencias LLAVECERRADO
         ;

   condicion_revisar ::= REVISAR PARENTESISABIERTO expresion_numerica PARENTESISCERRADO LLAVEABIERTO revisar0 LLAVECERRADO
                       ;

   revisar0 ::= CASO expresion_numerica: lista_sentencias SALIR
               | DEFECTO: lista_sentencias SALIR
               ;*/

/*
   asignacion ::= NUM asignacion
                | CAD asignacion
                | BOOL asignacion
                ;


   num ::= NUMERO VAR:v num0
         ;

   num0 ::= expresion_numerica;



   cad ::= CADENA VAR:v cad0
         ;

   cad0 ::= expresion_cadena;



   boo ::= BOOL VAR:v boo0
         ;

   boo0 ::= expresion_booleana;
*/
    //TODO: Extender las expresiones booleanas
    //expresion_booleana ::= VERDADERO
    //                    | FALSO
                  //      ;
/* La gramatica de nuestro analizador.
   
   expr_list ::=   expr_list expr_part
                                {: System.out.println();:}
                 | expr_part
   expr_part ::=   expr SEMI
   expr      ::=   expr PLUS factor
                                {: System.out.println();:}
                 | expr MINUS factor
                                {: System.out.println();:}
                 | factor
   factor    ::=   factor TIMES term
                                {: System.out.println();:}
                 | factor DIVIDE term
                                {: System.out.println();:}
                 | term
   term     ::=    LPAREN expr RPAREN
                                {: System.out.println();:}
                 | NUMBER
                                {: System.out.println();:}
                 | ID
*/
   
/* 'expr_list' es la raiz de la gramatica. Una 'expr_list' puede ser una 'expr_list'
   seguida de una expr_part, o puede ser una expr_part.
   Un terminal o no terminal se define <termino> ::= termino1 termino2 ... terminoN.;
   donde termino puede ser terminal o no terminal, solo se permite un simbolo a la
   izquierda. La                {: System.out.println();:}
   | sirve para indicar que es una produccion u otra.
   Debemos pasar de simbolos no terminales a simbolos terminales. Una gramatica que no
   termina en simbolos terminales se dice que no reduce, y por lo tanto nunca se finaliza
   su procesado.
*/



    lista_expresiones ::= expresion lista_expresiones      //{: System.out.println(e);:}//{: System.out.println(sym.terminalNames[e.sym]);:}
                  | expresion             //{: System.out.println(e);:}//{: System.out.println(sym.terminalNames[e.sym]);:}
                  ;

    expresion ::= Y                 {: System.out.println("Y");:}
                | O                 {: System.out.println("O");:}
                | SI                {: System.out.println("SI");:}
                | SINO              {: System.out.println("SINO");:}
                | DEVOLVER          {: System.out.println("DEVOLVER");:}
                | REC               {: System.out.println("REC");:}
                //| CAD               {: System.out.println("CAD");:}
                //| BOOL              {: System.out.println("BOOL");:}

                | IMPRIMIR          {: System.out.println("IMPRIMIR");:}
                | LEER              {: System.out.println("LEER");:}
                | FIN               {: System.out.println("FIN");:}
                | VERDADERO         {: System.out.println("VERDADERO");:}
                | FALSO             {: System.out.println("FALSO");:}
                | IMPORTAR          {: System.out.println("IMPORTAR");:}
                | INTENTAR          {: System.out.println("INTENTAR");:}
                | ATRAPAR           {: System.out.println("ATRAPAR");:}
                | LANZAR            {: System.out.println("LANZAR");:}
                | CONSTANTE         {: System.out.println("CONSTANTE");:}
                | REVISAR           {: System.out.println("REVISAR");:}
                | CASO              {: System.out.println("CASO");:}
                | COMO              {: System.out.println("COMO");:}
                | DEFECTO           {: System.out.println("DEFECTO");:}
                | CON               {: System.out.println("CON");:}
                | TERMINAR          {: System.out.println("TERMINAR");:}
                | EXCEPTO           {: System.out.println("EXCEPTO");:}
                | MOSTRAR           {: System.out.println("MOSTRAR");:}
                | EJECUTAR          {: System.out.println("EJECUTAR");:}
                //| NUM               {: System.out.println("NUM");:}
                | EN                {: System.out.println("EN");:}
                | CONTINUAR         {: System.out.println("CONTINUAR");:}
                | FINALMENTE        {: System.out.println("FINALMENTE");:}
                | MEI               {: System.out.println("MEI");:}
                | MAI               {: System.out.println("MAI");:}
                | II                {: System.out.println("II");:}
                | MENORQUE          {: System.out.println("MENORQUE");:}
                | MAYORQUE          {: System.out.println("MAYORQUE");:}
                | MENOROIGUAL       {: System.out.println("MENOROIGUAL");:}
                | MAYOROIGUAL       {: System.out.println("MAYOROIGUAL");:}
                | DISTINTO          {: System.out.println("DISTINTO");:}
                | SUMA              {: System.out.println("SUMA");:}
                | RESTA             {: System.out.println("RESTA");:}
                | MULTIPLICACION    {: System.out.println("MUTIPLICACION");:}
                | DIVISION          {: System.out.println("DIVISION");:}
                | MOD               {: System.out.println("MOD");:}
                | ASIGNACION        {: System.out.println("ASIGNACION");:}
                | IGUAL             {: System.out.println("IGUAL");:}
                | CORCHETEABIERTO   {: System.out.println("CORCHETEABIERTO");:}
                | CORCHETECERRADO   {: System.out.println("CORCHETECERRADO");:}
                | PARENTESISABIERTO {: System.out.println("PARENTESISABIERTO");:}
                | PARENTESISCERRADO {: System.out.println("PARENTESISCERRADO");:}
                | DOSPUNTOS         {: System.out.println("DOSPUNTOS");:}
                | NUMERO:e          {: System.out.println("NUMERO " + e);:}
                //| VAR:e             {: System.out.println("VAR " + e);:}
                | DELIMITADOR:e     {: System.out.println("DELIMITADOR " + e);:}
                | CADENA:e          {: System.out.println("CADENA" + e);:}
                ;
    /*
    expr_list ::= expr_list expr_part
                  |
                  expr_part
                  ;
    */
/* 'expr_part' se compone de una expr seguida de SEMI, o de una asign seguida de SEMI.
   asign:a esta estableciendo que a representa al objeto asociado a asign               {: System.out.println();:}
   | entre {: :}
   se coloca el sodigo en java para las acciones a tomar al cumplirse una produccion.
*/
/*
   expr_part ::= expr:e
                  {:
                    System.out.println(" = " + e); 
                  :} 
                  SEMI
                 ;
*/
/* 'expr' puede ser una expresion que inicia por numero entero op_suma expr,
  de esa forma se realiza una suma. Tambien puede ser un numero entero, con esto
  se devuelve el valor del entero. En RESULT se almacena el valor de las acciones,
  y se pasa al siguiente nivel de la gramatica.
*/              

/*   expr      ::=  expr:e OP_SUMA factor:f
                  {:
                    RESULT = new Integer(e.intValue() + f.intValue());
                  :}
                  |
                  expr:e OP_RESTA factor:f
                  {:
                    RESULT = new Integer(e.intValue() - f.intValue());
                  :}
                  |
                  factor:n
                  {:
                    RESULT = n; 
                  :}
                  ;
*/
/*factor        ::=  factor:f OP_MULT termino:e
                  {:
                    RESULT = new Integer(f.intValue() * e.intValue());
                  :}
                  |
                  termino:t
                  {:
                    RESULT = t;
                  :}
                  ;
*/
/*termino       ::=  PARENIZQ expr:e PARENDER
                  {:
                    RESULT = e;
                  :}
                  |
                  ENTERO:e
                  {:
                    RESULT = e;
                  :}
                  ;
*/