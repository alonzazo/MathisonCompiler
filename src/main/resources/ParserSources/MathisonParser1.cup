 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package SyntacticalAnalizer;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import LexicalAnalizer.Lexer;
import java.util.Scanner;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
        //--------------------------------------------------------INICIO DE INTERVENCIÓN
            //Intervención para no tomar como entrada los parámetros del programa
            System.out.println("Escriba la dirección del archivo que desea analizar:");
            Scanner scan = new Scanner(System.in);
            args = scan.nextLine().split(" ");
            //--------------------------------------------------------FIN DE INTERVENCIÓN

            if (args.length == 0) {
              System.out.println("Usage : java Lexer [ --encoding <name> ] <inputfile(s)>");
            }
            else {
              int firstFilePos = 0;
              String encodingName = "UTF-8";
              if (args[0].equals("--encoding")) {
                firstFilePos = 2;
                encodingName = args[1];
                try {
                  java.nio.charset.Charset.forName(encodingName); // Side-effect: is encodingName valid?
                } catch (Exception e) {
                  System.out.println("Invalid encoding '" + encodingName + "'");
                  return;
                }
              }
              for (int i = firstFilePos; i < args.length; i++) {
                Lexer lexer = null;
                try {

                  //String path = Lexer.class.getResource(args[i]).getPath();
                  //java.io.FileInputStream stream = new java.io.FileInputStream(path);

                  //Se utiliza getResource para como root la carpeta Resources como Root
                    java.io.Reader reader = new java.io.InputStreamReader(Parser.class.getResourceAsStream("../" + args[i]), encodingName);
                    lexer = new Lexer(reader);
                                        //--------------------------------------------------------Aplicacion de PARSER
                                      Parser asin = new Parser(lexer);
                                        Object result = asin.parse().value;
                }
                catch (java.io.FileNotFoundException e) {
                  System.out.println("File not found : \""+args[i]+"\"" + e.getMessage());
                }
                catch (java.io.IOException e) {
                  System.out.println("IO error scanning file \""+args[i]+"\"");
                  System.out.println(e);
                }
                catch (Exception e) {
                  System.out.println("Unexpected exception:");
                  e.printStackTrace();
                }
              }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */

//PALABRAS RESERVADAS
terminal    Y, O, PARA, DESDE, HASTA, AVANCE, MIENTRAS, HACER, SI;
terminal    SINO, DEVOLVER, PROC, CLASE, REC, CAD, BOOL, PUBLICO;
terminal    PRIVADO, IMPRIMIR, LEER, FIN, VERDADERO, FALSO, IMPORTAR;
terminal    INTENTAR, ATRAPAR, LANZAR, CONSTANTE, REVISAR, CASO;
terminal    COMO, DEFECTO, CON, TERMINAR, EXCEPTO, MOSTRAR, EJECUTAR, NUM;
terminal    EN, CONTINUAR, FINALMENTE;

//COMPARACION
terminal    MEI, MAI, II, MENORQUE, MAYORQUE, MENOROIGUAL,MAYOROIGUAL,DISTINTO,IGUAL;

//ASGNACION
terminal ASIGNACION;


//ARITMETICA
terminal    SUMA, RESTA, MULTIPLICACION, DIVISION, MOD;

//DELIMITADOR
terminal    CORCHETEABIERTO,CORCHETECERRADO,LLAVEABIERTO,LLAVECERRADO,PARENTESISABIERTO,PARENTESISCERRADO, DOSPUNTOS, COMA;

terminal SALIR;

//CON VALOR ASOCIADO
terminal    Double NUMERO;
terminal    String VAR;
terminal    String DELIMITADOR;
terminal    String CADENA;

/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
//non terminal Object     expr_list, expr_part;
//non terminal Integer    expr, factor, termino;

non terminal    programa, lista_clases, clase, cuerpo_clase, c_metodo;
non terminal    lista_expresiones, expresion, lista_parametros, expresion_booleana, variable_arreglo;
non terminal    c_vista,  c_tipo_metodo, lista_metodos, c_declaracion_metodo;
non terminal    c_declaracion,c_tipo;

non terminal c_expresion_variable;
non terminal c_expresion_variable_mayorque, c_expresion_variable_mayoroigual, c_expresion_variable_menorque,c_expresion_variable_menoroigual;
non terminal c_expresion_variable_igual, c_expresion_variable_distinto;
non terminal c_expresion_variable_comparacion;
non terminal c_expresion_variable_concatena, c_expresion_variable_concatena_prima;

non terminal c_expresion_numerica;  //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Numerica_Total; //El total

non terminal c_expresion_booleana; //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Booleana_Total;

non terminal c_expresion_cadena; //Todas las operaciones excepto solamente el nombre e la variable
non terminal c_asignacion_expresion_Cadena_total; //El totall

non terminal c_asignacion, c_asignacion_prima;
non terminal c_asignacion_numerica;
non terminal c_asignacion_cadena;
non terminal c_asignacion_booleana;

/*Llamado a Metodos*/
non terminal c_variable_o_llamadoMetodo;
non terminal c_llamadoMetodo;
non terminal c_expresion_llamado_metodo, c_lleno_parametros, c_hay_parametro; //Estan en trabajo

/*Estructuras de control*/
non terminal c_estructuras;
non terminal c_para;
non terminal c_mientras;
non terminal c_si, c_sino;
non terminal c_revisar, c_revisar_casos;

/* Lineas validas */
non terminal c_lista_sentencias;



nonterminal cuerpo_metodo;

/*Inicio de las precedence, se guian en base a la documentacion de java
Entre más abajo esten tienen más prioridad*/

precedence nonassoc DISTINTO,IGUAL,MENORQUE,MENOROIGUAL,MAYORQUE,MAYOROIGUAL;

precedence left Y,O;

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MOD;

precedence left COMA;

precedence left PARENTESISABIERTO,PARENTESISCERRADO;


start with programa;

programa ::= clase programa
           //| c_asignacion programa
           | clase
           ;

/*------------------------------Declaracion Basica ------------------------------*/
c_declaracion ::= c_tipo VAR:v
                ;

/*------------------------------Primitivas de tipo de datos------------------------------*/

c_tipo ::= CAD
         | NUM
         | BOOL
         | VAR:tipo_no_primitivo  //Una clase
         ;

/*-------------------------Sintaxis de las variables y operaciones con variables------------------------*/

c_variable_o_llamadoMetodo ::= c_expresion_variable
                             | c_llamadoMetodo
                             ;

c_llamadoMetodo ::= c_expresion_llamado_metodo
                  | PARENTESISABIERTO c_llamadoMetodo PARENTESISCERRADO
                  ;

c_expresion_variable ::= VAR:v
                       | PARENTESISABIERTO c_expresion_variable PARENTESISCERRADO
                       ;

c_expresion_variable_concatena ::= c_variable_o_llamadoMetodo SUMA c_expresion_variable_concatena

                                 //| c_variable_o_llamadoMetodo SUMA c_variable_o_llamadoMetodo
                                 | c_expresion_variable SUMA c_variable_o_llamadoMetodo
                                 | c_llamadoMetodo SUMA c_variable_o_llamadoMetodo

                                 | PARENTESISABIERTO c_expresion_variable_concatena PARENTESISCERRADO
                                 ;


c_expresion_variable_igual ::= c_asignacion_expresion_Numerica_Total IGUAL c_asignacion_expresion_Numerica_Total
                             | PARENTESISABIERTO c_expresion_variable_igual PARENTESISCERRADO
                             ;

c_expresion_variable_distinto ::= c_asignacion_expresion_Numerica_Total DISTINTO c_asignacion_expresion_Numerica_Total
                               | PARENTESISABIERTO c_expresion_variable_distinto PARENTESISCERRADO
                               ;

c_expresion_variable_mayorque ::= c_asignacion_expresion_Numerica_Total MAYORQUE c_asignacion_expresion_Numerica_Total
                                | PARENTESISABIERTO c_expresion_variable_mayorque PARENTESISCERRADO
                                ;


c_expresion_variable_mayoroigual ::= c_asignacion_expresion_Numerica_Total MAYOROIGUAL c_asignacion_expresion_Numerica_Total
                                   | PARENTESISABIERTO c_expresion_variable_mayoroigual MAYOROIGUAL
                                   ;

c_expresion_variable_menorque ::= c_asignacion_expresion_Numerica_Total MENORQUE c_asignacion_expresion_Numerica_Total
                                | PARENTESISABIERTO c_expresion_variable_menorque PARENTESISCERRADO
                                ;


c_expresion_variable_menoroigual ::= c_asignacion_expresion_Numerica_Total MENOROIGUAL c_asignacion_expresion_Numerica_Total
                                   | PARENTESISABIERTO c_expresion_variable_menoroigual PARENTESISCERRADO
                                   ;

c_expresion_variable_comparacion ::= c_expresion_variable_igual
                                   | c_expresion_variable_distinto
                                   | c_expresion_variable_mayorque
                                   | c_expresion_variable_mayoroigual
                                   | c_expresion_variable_menorque
                                   | c_expresion_variable_menoroigual
                                   ;

/*------------------------------Declaracion de las asignaciones------------------------------*/

c_asignacion ::= c_tipo VAR:v c_asignacion_prima              //num pi = 3.14
               ;

/*c_asignacion ::= c_asignacion_numerica              //num pi = 3.14
               | c_asignacion_cadena                //cad mensaje = "Me llamo viernes"
               | c_asignacion_booleana              //bool mentiroso = (true == false) == true
               ;
*/
/*------------------------------Sintaxis asignacion de tipo numericas------------------------------*/

c_asignacion_prima ::=  ASIGNACION c_asignacion_expresion_Numerica_Total        //Asignacion numerica
                    |   ASIGNACION c_asignacion_expresion_Cadena_total
                    |   ASIGNACION c_asignacion_expresion_Booleana_Total
                    |   ASIGNACION c_variable_o_llamadoMetodo
                    ;
/*c_asignacion_numerica ::= NUM VAR:v ASIGNACION c_asignacion_expresion_Numerica_Total
                        ;*/


c_asignacion_expresion_Numerica_Total ::= c_expresion_numerica //Corresponde a todas aquellas menos las que tienen solo variables
                                        ;


c_expresion_numerica  ::= c_expresion_numerica SUMA c_expresion_numerica
                        | c_expresion_numerica RESTA c_expresion_numerica
                        | c_expresion_numerica MULTIPLICACION c_expresion_numerica
                        | c_expresion_numerica DIVISION c_expresion_numerica

                        //Una variable + otra cosa

                        | c_variable_o_llamadoMetodo SUMA c_expresion_numerica
                        | c_expresion_numerica SUMA c_variable_o_llamadoMetodo

                        | c_variable_o_llamadoMetodo RESTA c_expresion_numerica
                        | c_expresion_numerica RESTA c_variable_o_llamadoMetodo

                        | c_variable_o_llamadoMetodo MULTIPLICACION c_expresion_numerica
                        | c_expresion_numerica MULTIPLICACION c_variable_o_llamadoMetodo

                        | c_variable_o_llamadoMetodo DIVISION c_expresion_numerica
                        | c_expresion_numerica DIVISION c_variable_o_llamadoMetodo

                        //Dos variables

                        | c_variable_o_llamadoMetodo SUMA c_variable_o_llamadoMetodo//Todo Marcador
                        | c_variable_o_llamadoMetodo RESTA c_variable_o_llamadoMetodo
                        | c_variable_o_llamadoMetodo MULTIPLICACION c_variable_o_llamadoMetodo
                        | c_variable_o_llamadoMetodo DIVISION c_variable_o_llamadoMetodo

                        //Terminos
                        | NUMERO:v                                                  {:System.out.println("Numero " + v);:}
                        | PARENTESISABIERTO c_expresion_numerica PARENTESISCERRADO
                        ;

c_asignacion_expresion_Cadena_total ::= c_expresion_cadena  //Cuando al menos una no es una variable
                                      | c_expresion_variable_concatena //Concatenacion (Al menos dos) de puras variables o llamado a metodos
                                      ;

/*------------------------------Sintaxis de tipo cadena tipo numericas------------------------------*/

/*c_asignacion_cadena ::= CAD VAR:v ASIGNACION c_asignacion_expresion_Cadena_total
                      ;*/

c_expresion_cadena ::= c_expresion_cadena SUMA c_expresion_cadena
                     //Una variable + otra cosa
                     | c_variable_o_llamadoMetodo SUMA c_expresion_cadena
                     | c_expresion_cadena SUMA c_variable_o_llamadoMetodo
                     | CADENA:v                                             {:System.out.println("Cadena " + v);:}
                     //|c_nombre_metodo
                     | PARENTESISABIERTO c_expresion_cadena PARENTESISCERRADO
                     ;

/*------------------------------ Sintaxis de tipo cadena tipo booleana------------------------------*/

c_asignacion_expresion_Booleana_Total ::= c_expresion_booleana //Corresponde a todas las operaciones excpeto cuando todas son variables
                                        ;

/*c_asignacion_booleana ::= BOOL VAR:V ASIGNACION c_asignacion_expresion_Booleana_Total
                        ;
*/

c_expresion_booleana::= c_expresion_booleana  Y c_expresion_booleana
                      | c_expresion_booleana O c_expresion_booleana

                      //Una variables o más + otra cosa

                      | c_variable_o_llamadoMetodo Y c_expresion_booleana
                      | c_expresion_booleana Y c_variable_o_llamadoMetodo

                      | c_variable_o_llamadoMetodo O c_expresion_booleana
                      | c_expresion_booleana O c_variable_o_llamadoMetodo

                      //Dos variables o más + otra cosa

                      | c_variable_o_llamadoMetodo Y c_variable_o_llamadoMetodo
                      | c_variable_o_llamadoMetodo O c_variable_o_llamadoMetodo

                      | c_expresion_variable_comparacion
                      | VERDADERO
                      | FALSO
                      | PARENTESISABIERTO c_expresion_booleana PARENTESISCERRADO

                        ;

/*------------------------------ Sintaxis de los metodos ------------------------------*/

c_expresion_llamado_metodo ::= VAR:v PARENTESISABIERTO c_lleno_parametros PARENTESISCERRADO
                             ;

c_lleno_parametros ::= c_hay_parametro
                     | PARENTESISABIERTO c_lleno_parametros PARENTESISCERRADO
                     |
                     ;

c_hay_parametro ::= c_hay_parametro COMA c_hay_parametro
                  | c_variable_o_llamadoMetodo
                  //| c_expresion_variable_concatena
                  /*Demás expresiones sin variable*/
                  | c_expresion_numerica
                  | c_expresion_cadena
                  | c_expresion_booleana
                  | PARENTESISABIERTO c_hay_parametro PARENTESISCERRADO
                  ;

//c_definicion::= NUM c_asignacion_numerica
//|CAD c_asignacion_cadena
//|BOOL c_asignacion_booleana
  //;

/*-----------------------------Sintaxis de estructuras de control-------------------------- */

c_estructuras ::= c_para
                | c_mientras
                | c_si
                | c_revisar
                ;

c_para ::= PARA VAR:v DESDE c_expresion_numerica HASTA c_expresion_numerica
           AVANCE c_expresion_numerica LLAVEABIERTO c_lista_sentencias LLAVECERRADO
         ;

c_mientras ::= MIENTRAS PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO
               HACER LLAVEABIERTO c_lista_sentencias LLAVECERRADO
             | HACER LLAVEABIERTO c_lista_sentencias LLAVECERRADO MIENTRAS
               PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO DELIMITADOR
             ;

c_si ::= SI PARENTESISABIERTO c_asignacion_expresion_Booleana_Total PARENTESISCERRADO LLAVEABIERTO c_lista_sentencias LLAVECERRADO c_sino
                 ;

c_sino ::= SINO c_si
         | SINO LLAVEABIERTO c_lista_sentencias LLAVECERRADO c_sino
         |
         ;

c_revisar ::= REVISAR PARENTESISABIERTO VAR:v PARENTESISCERRADO LLAVEABIERTO c_revisar_casos LLAVECERRADO
                       ;

c_revisar_casos ::= CASO c_expresion_numerica DOSPUNTOS c_lista_sentencias SALIR
                  | DEFECTO DOSPUNTOS c_lista_sentencias SALIR
                  ;

c_lista_sentencias ::= c_asignacion c_lista_sentencias
                     //| c_estructuras c_lista_sentencias
                     | c_expresion_llamado_metodo c_lista_sentencias
                     | //c_asignacion
                     //| c_expresion_llamado_metodo
                     //| c_estructuras
                     ;

   /*   programa ::= clase programa
                | metodo programa
                | clase
                | metodo
                ;*/

/* ------------------------------ SSintaxis de la estructura de un programa ------------------------------*/

clase ::= c_vista CLASE VAR:v LLAVEABIERTO cuerpo_clase LLAVECERRADO {: System.out.println("CLASE " + v);:}
        ;

c_metodo ::= c_vista c_tipo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v);:}
            | c_vista c_tipo VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v);:}
            | c_vista PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v);:}
            | c_vista PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v);:}
            | c_tipo VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v);:}
            | c_tipo VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v);:}
            | PROC VAR:v PARENTESISABIERTO lista_parametros PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO     {: System.out.println("METODO " + v);:}
            | PROC VAR:v PARENTESISABIERTO PARENTESISCERRADO LLAVEABIERTO cuerpo_metodo LLAVECERRADO                      {: System.out.println("METODO " + v);:}
            ;

c_vista ::= PUBLICO
          | PRIVADO
          ;

lista_parametros ::= c_tipo variable_arreglo COMA lista_parametros      {: System.out.println("Parámetro"); :}
                   | c_tipo variable_arreglo                            {: System.out.println("Parámetro"); :}
                   ;

variable_arreglo ::= VAR:v
                   | VAR:v CORCHETEABIERTO CORCHETECERRADO
                   ;

cuerpo_clase ::= c_metodo cuerpo_clase
               | c_asignacion cuerpo_clase
               |
               ;

cuerpo_metodo ::= c_lista_sentencias //cuerpo_metodo
                    //| variable_arreglo
                    //|
                    ;

/* La gramatica de nuestro analizador.
   
   expr_list ::=   expr_list expr_part
                                {: System.out.println();:}
                 | expr_part
   expr_part ::=   expr SEMI
   expr      ::=   expr PLUS factor
                                {: System.out.println();:}
                 | expr MINUS factor
                                {: System.out.println();:}
                 | factor
   factor    ::=   factor TIMES term
                                {: System.out.println();:}
                 | factor DIVIDE term
                                {: System.out.println();:}
                 | term
   term     ::=    LPAREN expr RPAREN
                                {: System.out.println();:}
                 | NUMBER
                                {: System.out.println();:}
                 | ID
*/
   
/* 'expr_list' es la raiz de la gramatica. Una 'expr_list' puede ser una 'expr_list'
   seguida de una expr_part, o puede ser una expr_part.
   Un terminal o no terminal se define <termino> ::= termino1 termino2 ... terminoN.;
   donde termino puede ser terminal o no terminal, solo se permite un simbolo a la
   izquierda. La                {: System.out.println();:}
   | sirve para indicar que es una produccion u otra.
   Debemos pasar de simbolos no terminales a simbolos terminales. Una gramatica que no
   termina en simbolos terminales se dice que no reduce, y por lo tanto nunca se finaliza
   su procesado.
*/



   /* lista_expresiones ::= expresion lista_expresiones      //{: System.out.println(e);:}//{: System.out.println(sym.terminalNames[e.sym]);:}
                  | expresion             //{: System.out.println(e);:}//{: System.out.println(sym.terminalNames[e.sym]);:}
                  ;

    expresion ::= Y                 {: System.out.println("Y");:}
                | O                 {: System.out.println("O");:}
                | SI                {: System.out.println("SI");:}
                | SINO              {: System.out.println("SINO");:}
                | DEVOLVER          {: System.out.println("DEVOLVER");:}
                | REC               {: System.out.println("REC");:}
                //| CAD               {: System.out.println("CAD");:}
                //| BOOL              {: System.out.println("BOOL");:}

                | IMPRIMIR          {: System.out.println("IMPRIMIR");:}
                | LEER              {: System.out.println("LEER");:}
                | FIN               {: System.out.println("FIN");:}
                | VERDADERO         {: System.out.println("VERDADERO");:}
                | FALSO             {: System.out.println("FALSO");:}
                | IMPORTAR          {: System.out.println("IMPORTAR");:}
                | INTENTAR          {: System.out.println("INTENTAR");:}
                | ATRAPAR           {: System.out.println("ATRAPAR");:}
                | LANZAR            {: System.out.println("LANZAR");:}
                | CONSTANTE         {: System.out.println("CONSTANTE");:}
                | REVISAR           {: System.out.println("REVISAR");:}
                | CASO              {: System.out.println("CASO");:}
                | COMO              {: System.out.println("COMO");:}
                | DEFECTO           {: System.out.println("DEFECTO");:}
                | CON               {: System.out.println("CON");:}
                | TERMINAR          {: System.out.println("TERMINAR");:}
                | EXCEPTO           {: System.out.println("EXCEPTO");:}
                | MOSTRAR           {: System.out.println("MOSTRAR");:}
                | EJECUTAR          {: System.out.println("EJECUTAR");:}
                //| NUM               {: System.out.println("NUM");:}
                | EN                {: System.out.println("EN");:}
                | CONTINUAR         {: System.out.println("CONTINUAR");:}
                | FINALMENTE        {: System.out.println("FINALMENTE");:}
                | MEI               {: System.out.println("MEI");:}
                | MAI               {: System.out.println("MAI");:}
                | II                {: System.out.println("II");:}
                | MENORQUE          {: System.out.println("MENORQUE");:}
                | MAYORQUE          {: System.out.println("MAYORQUE");:}
                | MENOROIGUAL       {: System.out.println("MENOROIGUAL");:}
                | MAYOROIGUAL       {: System.out.println("MAYOROIGUAL");:}
                | DISTINTO          {: System.out.println("DISTINTO");:}
                | SUMA              {: System.out.println("SUMA");:}
                | RESTA             {: System.out.println("RESTA");:}
                | MULTIPLICACION    {: System.out.println("MUTIPLICACION");:}
                | DIVISION          {: System.out.println("DIVISION");:}
                | MOD               {: System.out.println("MOD");:}
                | ASIGNACION        {: System.out.println("ASIGNACION");:}
                | IGUAL             {: System.out.println("IGUAL");:}
                | CORCHETEABIERTO   {: System.out.println("CORCHETEABIERTO");:}
                | CORCHETECERRADO   {: System.out.println("CORCHETECERRADO");:}
                | PARENTESISABIERTO {: System.out.println("PARENTESISABIERTO");:}
                | PARENTESISCERRADO {: System.out.println("PARENTESISCERRADO");:}
                | DOSPUNTOS         {: System.out.println("DOSPUNTOS");:}
                | NUMERO:e          {: System.out.println("NUMERO " + e);:}
                //| VAR:e             {: System.out.println("VAR " + e);:}
                | DELIMITADOR:e     {: System.out.println("DELIMITADOR " + e);:}
                | CADENA:e          {: System.out.println("CADENA" + e);:}
                ;
    /*
    expr_list ::= expr_list expr_part
                  |
                  expr_part
                  ;
    */
/* 'expr_part' se compone de una expr seguida de SEMI, o de una asign seguida de SEMI.
   asign:a esta estableciendo que a representa al objeto asociado a asign               {: System.out.println();:}
   | entre {: :}
   se coloca el sodigo en java para las acciones a tomar al cumplirse una produccion.
*/
/*
   expr_part ::= expr:e
                  {:
                    System.out.println(" = " + e); 
                  :} 
                  SEMI
                 ;
*/
/* 'expr' puede ser una expresion que inicia por numero entero op_suma expr,
  de esa forma se realiza una suma. Tambien puede ser un numero entero, con esto
  se devuelve el valor del entero. En RESULT se almacena el valor de las acciones,
  y se pasa al siguiente nivel de la gramatica.
*/              

/*   expr      ::=  expr:e OP_SUMA factor:f
                  {:
                    RESULT = new Integer(e.intValue() + f.intValue());
                  :}
                  |
                  expr:e OP_RESTA factor:f
                  {:
                    RESULT = new Integer(e.intValue() - f.intValue());
                  :}
                  |
                  factor:n
                  {:
                    RESULT = n; 
                  :}
                  ;
*/
/*factor        ::=  factor:f OP_MULT termino:e
                  {:
                    RESULT = new Integer(f.intValue() * e.intValue());
                  :}
                  |
                  termino:t
                  {:
                    RESULT = t;
                  :}
                  ;
*/
/*termino       ::=  PARENIZQ expr:e PARENDER
                  {:
                    RESULT = e;
                  :}
                  |
                  ENTERO:e
                  {:
                    RESULT = e;
                  :}
                  ;
*/